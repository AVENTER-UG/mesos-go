// +build ignore

package main

import (
	"os"
	"text/template"
)

func main() {
	Run(handlersTemplate, nil, os.Args...)
}

var handlersTemplate = template.Must(template.New("").Parse(`package {{.Package}}

// go generate {{.Args}}
// GENERATED CODE FOLLOWS; DO NOT EDIT.

import (
	"context"

	"github.com/mesos/mesos-go/api/v1/lib"
	"github.com/mesos/mesos-go/api/v1/lib/client"
	"github.com/mesos/mesos-go/api/v1/lib/httpcli"
{{range .Imports}}{{/* a "calls" package is assumed to be imported */}}
	{{ printf "%q" . -}}
{{end}}
)

{{.RequireType "C" -}}{{/* C is assumed to be a pointer type */ -}}
type ResponseClassifier func({{.Type "C"}}) (client.ResponseClass, error)

{{/* classifyResponse must be declared in the package wherein this generated module lives */ -}}
var DefaultResponseClassifier = ResponseClassifier(classifyResponse)

// NewSender generates a sender that uses the Mesos v1 HTTP API for encoding/decoding requests/responses.
// The ResponseClass is inferred from the first object generated by the given Request.
func NewSender(c *httpcli.Client) calls.Sender {
	return calls.SenderFunc(func(ctx context.Context, r calls.Request) (mesos.Response, error) {
		var (
			obj     = r.Call()
			rc, err = DefaultResponseClassifier(obj)
		)
		if err != nil {
			return nil, err
		}

		var req client.Request

		switch r.(type) {
		case calls.RequestStreaming:
			first := true
			req = calls.RequestStreamingFunc(func() {{.Type "C"}} {
				if first {
					first = false
					return obj
				}
				return r.Call()
			})
		default:
			req = calls.NonStreaming(obj)
		}

		return c.Send(req, rc, httpcli.Context(ctx))
	})
}
`))
