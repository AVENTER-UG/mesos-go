package httpsched

import (
	"errors"
	"log"
	"net/http"
	"net/url"
	"time"

	"github.com/mesos/mesos-go"
	"github.com/mesos/mesos-go/backoff"
	"github.com/mesos/mesos-go/encoding"
	"github.com/mesos/mesos-go/httpcli"
	"github.com/mesos/mesos-go/scheduler"
)

const (
	headerMesosStreamID = "Mesos-Stream-Id"
	debug               = false
)

var (
	errMissingMesosStreamId = errors.New("missing Mesos-Stream-Id header expected with successful SUBSCRIBE")
	errNotHTTP              = errors.New("expected an HTTP object, found something else instead")
	errBadLocation          = errors.New("failed to build new Mesos service endpoint URL from Location header")

	DefaultRedirectSettings = RedirectSettings{
		MaxAttempts:      9,
		MaxBackoffPeriod: 13 * time.Second,
		MinBackoffPeriod: 100 * time.Millisecond,
	}
)

type (
	RedirectSettings struct {
		MaxAttempts      int           // per httpDo invocation
		MaxBackoffPeriod time.Duration // should be more than minBackoffPeriod
		MinBackoffPeriod time.Duration // should be less than maxBackoffPeriod
	}

	client struct {
		*httpcli.Client
		redirect RedirectSettings
	}

	// Caller is the public interface this framework scheduler's should consume
	Caller interface {
		// httpDo is intentionally package-private; clients of this package may extend a Caller
		// generated by this package by overriding the Call func but may not customize httpDo.
		httpDo(encoding.Marshaler, ...httpcli.RequestOpt) (mesos.Response, error)

		// Call issues a call to Mesos and properly manages call-specific HTTP response headers & data.
		// Subscriptions that succeed return a non-nil Caller that should be used for duration of the subscription.
		Call(*scheduler.Call) (mesos.Response, Caller, error)
	}

	// CallerAdapter is a convenience type that allows clients to more simply decorate an existing Caller.
	CallerAdapter struct {
		// Caller is expected to be decorated by a CallFunc implementation. This SHOULD NOT be a nil reference.
		Caller
		// CallFunc is invoked upon calls to CallerAdapter.Call; if not specified then the invocation is
		// passed through to the embedded Caller.
		CallFunc func(*scheduler.Call) (mesos.Response, Caller, error)
	}

	// Decorator funcs usually return a Caller whose behavior has been somehow modified
	Decorator func(Caller) Caller

	Decorators []Decorator

	callerInternal interface {
		Caller
		// WithTemporary configures the Client with the temporary option and returns the results of
		// invoking f(). Changes made to the Client by the temporary option are reverted before this
		// func returns.
		WithTemporary(opt httpcli.Opt, f func() error) error
	}

	// Option is a functional configuration option type
	Option func(*client) Option

	callerTemporary struct {
		callerInternal                      // delegate actually does the work
		requestOpts    []httpcli.RequestOpt // requestOpts are temporary per-request options
		opt            httpcli.Opt          // opt is a temporary client option
	}
)

// Apply is a convenient, nil-safe applicator that returns the result of d(c) iff d != nil; otherwise c
func (d Decorator) Apply(c Caller) (result Caller) {
	if d != nil {
		result = d(c)
	} else {
		result = c
	}
	return
}

func (ca *CallerAdapter) Call(call *scheduler.Call) (mesos.Response, Caller, error) {
	f := ca.CallFunc
	if f == nil && ca.Caller != nil {
		f = ca.Caller.Call
	}
	return f(call)
}

func (ct *callerTemporary) httpDo(m encoding.Marshaler, opt ...httpcli.RequestOpt) (resp mesos.Response, err error) {
	ct.callerInternal.WithTemporary(ct.opt, func() error {
		if len(opt) == 0 {
			opt = ct.requestOpts
		} else if len(ct.requestOpts) > 0 {
			opt = append(opt[:], ct.requestOpts...)
		}
		resp, err = ct.callerInternal.httpDo(m, opt...)
		return nil
	})
	return
}

func (ct *callerTemporary) Call(call *scheduler.Call) (resp mesos.Response, caller Caller, err error) {
	ct.callerInternal.WithTemporary(ct.opt, func() error {
		resp, caller, err = ct.callerInternal.Call(call)
		return nil
	})
	return
}

// MaxRedirects is a functional option that sets the maximum number of per-call HTTP redirects for a scheduler client
func MaxRedirects(mr int) Option {
	return func(c *client) Option {
		old := c.redirect.MaxAttempts
		c.redirect.MaxAttempts = mr
		return MaxRedirects(old)
	}
}

// NewCaller returns a scheduler API Client
func NewCaller(cl *httpcli.Client, opts ...Option) Caller {
	result := &client{Client: cl, redirect: DefaultRedirectSettings}
	cl.With(result.redirectHandler())
	for _, o := range opts {
		if o != nil {
			o(result)
		}
	}
	return result
}

// httpDo decorates the inherited behavior w/ support for HTTP redirection to follow Mesos leadership changes.
// NOTE: this implementation will change the state of the client upon Mesos leadership changes.
func (cli *client) httpDo(m encoding.Marshaler, opt ...httpcli.RequestOpt) (resp mesos.Response, err error) {
	var (
		done            chan struct{} // avoid allocating these chans unless we actually need to redirect
		redirectBackoff <-chan struct{}
		getBackoff      = func() <-chan struct{} {
			if redirectBackoff == nil {
				done = make(chan struct{})
				redirectBackoff = backoff.Notifier(cli.redirect.MinBackoffPeriod, cli.redirect.MaxBackoffPeriod, done)
			}
			return redirectBackoff
		}
	)
	defer func() {
		if done != nil {
			close(done)
		}
	}()
	for attempt := 0; ; attempt++ {
		resp, err = cli.Client.Do(m, opt...)
		redirectErr, ok := err.(*mesosRedirectionError)
		if !ok {
			return resp, err
		}
		if attempt < cli.redirect.MaxAttempts {
			log.Println("redirecting to " + redirectErr.newURL)
			cli.With(httpcli.Endpoint(redirectErr.newURL))
			<-getBackoff()
			continue
		}
		return
	}
}

// CallNoData is a convenience func that executes the given Call using the provided Caller
// and always drops the response data.
func CallNoData(caller Caller, call *scheduler.Call) error {
	resp, _, err := caller.Call(call)
	if resp != nil {
		resp.Close()
	}
	return err
}

// Call implements Client
func (cli *client) Call(call *scheduler.Call) (resp mesos.Response, exportCaller Caller, err error) {
	var (
		exec   = callerExec(prepareCall)
		caller = callerInternal(cli)
	)

	// initial "prepare"; special case: if it returns a terminal exec we'll attempt
	// to make a call anyway.
	caller, exec = exec(caller, call)

	// TODO(jdef) would it be cleaner to handle leadership changes here?
	for {
		resp, err = caller.httpDo(call)
		if err != nil {
			break
		}
		if exec == nil {
			// state machine finished
			break
		}

		// advance to the next exec state (subscribed?)
		caller, exec = exec(caller, call)
		if exec == nil {
			// state machine finished
			break
		}

		// discard intermediate responses, for now
		if resp != nil {
			resp.Close()
		}
	}
	exportCaller = caller
	return
}

// TODO(jdef) this is starting to feel like a functional state machine... can we simplify client
// interaction with this package accordingly?
type callerExec func(c callerInternal, call *scheduler.Call) (callerInternal, callerExec)

// prepare is invoked for scheduler call's that require pre-processing, post-processing, or both.
func prepareCall(client callerInternal, call *scheduler.Call) (callerInternal, callerExec) {
	switch call.GetType() {
	case scheduler.Call_SUBSCRIBE:
		mesosStreamID := ""
		undoable := httpcli.WrapDoer(func(f httpcli.DoFunc) httpcli.DoFunc {
			return func(req *http.Request) (*http.Response, error) {
				if debug {
					log.Println("wrapping request")
				}
				resp, err := f(req)
				if debug && err == nil {
					log.Printf("status %d", resp.StatusCode)
					for k := range resp.Header {
						log.Println("header " + k + ": " + resp.Header.Get(k))
					}
				}
				if err == nil && resp.StatusCode == 200 {
					// grab Mesos-Stream-Id header; if missing then
					// close the response body and return an error
					mesosStreamID = resp.Header.Get(headerMesosStreamID)
					if mesosStreamID == "" {
						resp.Body.Close()
						return nil, errMissingMesosStreamId
					}
					if debug {
						log.Println("found mesos-stream-id: " + mesosStreamID)
					}
				}
				return resp, err
			}
		})
		subscribeCaller := &callerTemporary{
			opt:            undoable,
			callerInternal: client,
			requestOpts:    []httpcli.RequestOpt{httpcli.Close(true)},
		}
		return subscribeCaller, func(callerInternal, *scheduler.Call) (callerInternal, callerExec) {
			return &callerTemporary{
				opt:            httpcli.DefaultHeader(headerMesosStreamID, mesosStreamID),
				callerInternal: client,
			}, nil
		}
	default:
		// there are no other, special calls that generate data and require pre/post processing
	}
	return client, nil
}

type mesosRedirectionError struct{ newURL string }

func (mre *mesosRedirectionError) Error() string {
	return "mesos server sent redirect to: " + mre.newURL
}

// redirectHandler returns a config options that decorates the default response handling routine;
// it transforms normal Mesos redirect "errors" into mesosRedirectionErrors by parsing the Location
// header and computing the address of the next endpoint that should be used to replay the failed
// HTTP request.
func (cli *client) redirectHandler() httpcli.Opt {
	return httpcli.HandleResponse(func(hres *http.Response, err error) (mesos.Response, error) {
		resp, err := cli.HandleResponse(hres, err) // default response handler
		if err == nil || (err != nil && err != httpcli.ErrNotLeader) {
			return resp, err
		}
		res, ok := resp.(*httpcli.Response)
		if !ok {
			if resp != nil {
				resp.Close()
			}
			return nil, errNotHTTP
		}
		log.Println("master changed?")
		location, ok := buildNewEndpoint(res.Header.Get("Location"), cli.Endpoint())
		if !ok {
			return nil, errBadLocation
		}
		res.Close()
		return nil, &mesosRedirectionError{location}
	})
}

func buildNewEndpoint(location, currentEndpoint string) (string, bool) {
	// TODO(jdef) refactor this
	// mesos v0.29 will actually send back fully-formed URLs in the Location header
	if location == "" {
		return "", false
	}
	// current format appears to be //x.y.z.w:port
	hostport, parseErr := url.Parse(location)
	if parseErr != nil || hostport.Host == "" {
		return "", false
	}
	current, parseErr := url.Parse(currentEndpoint)
	if parseErr != nil {
		return "", false
	}
	current.Host = hostport.Host
	return current.String(), true
}

var noopDecorator = Decorator(func(h Caller) Caller { return h })

// If returns the receiving Decorator if the given bool is true; otherwise returns a no-op
// Decorator instance.
func (d Decorator) If(b bool) Decorator {
	if d == nil {
		return noopDecorator
	}
	result := noopDecorator
	if b {
		result = d
	}
	return result
}

// Apply applies the Decorators in the order they're listed such that the last Decorator invoked
// generates the final (wrapping) Caller that is ultimately returned.
func (ds Decorators) Combine() (result Decorator) {
	actual := make(Decorators, 0, len(ds))
	for _, d := range ds {
		if d != nil {
			actual = append(actual, d)
		}
	}
	if len(actual) == 0 {
		result = noopDecorator
	} else {
		result = Decorator(func(h Caller) Caller {
			for _, d := range actual {
				h = d(h)
			}
			return h
		})
	}
	return
}

// CallerTracker invokes the tracking function `f` upon decorator invocation. This is a convenience
// decorator that allows a client to receive callbacks when, in some context, a Caller is updated.
func CallerTracker(f func(Caller)) Decorator {
	return func(c Caller) Caller {
		f(c)
		return c
	}
}
