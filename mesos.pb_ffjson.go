// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: mesos.pb.go
// DO NOT EDIT!

package mesos

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"reflect"
)

func (mj *Address) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Address) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Ip != nil {
		if true {
			buf.WriteString(`"ip":`)
			fflib.WriteJsonString(buf, string(*mj.Ip))
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"port":`)
	fflib.FormatBits2(buf, uint64(mj.Port), 10, mj.Port < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Addressbase = iota
	ffj_t_Addressno_such_key

	ffj_t_Address_Hostname

	ffj_t_Address_Ip

	ffj_t_Address_Port
)

var ffj_key_Address_Hostname = []byte("hostname")

var ffj_key_Address_Ip = []byte("ip")

var ffj_key_Address_Port = []byte("port")

func (uj *Address) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Address) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Addressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Addressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_Address_Hostname, kn) {
						currentKey = ffj_t_Address_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Address_Ip, kn) {
						currentKey = ffj_t_Address_Ip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Address_Port, kn) {
						currentKey = ffj_t_Address_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Address_Port, kn) {
					currentKey = ffj_t_Address_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Address_Ip, kn) {
					currentKey = ffj_t_Address_Ip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Address_Hostname, kn) {
					currentKey = ffj_t_Address_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Addressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Address_Hostname:
					goto handle_Hostname

				case ffj_t_Address_Ip:
					goto handle_Ip

				case ffj_t_Address_Port:
					goto handle_Port

				case ffj_t_Addressno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip:

	/* handler: uj.Ip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Port = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *AgentID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AgentID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AgentIDbase = iota
	ffj_t_AgentIDno_such_key

	ffj_t_AgentID_Value
)

var ffj_key_AgentID_Value = []byte("value")

func (uj *AgentID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AgentID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AgentIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AgentIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_AgentID_Value, kn) {
						currentKey = ffj_t_AgentID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AgentID_Value, kn) {
					currentKey = ffj_t_AgentID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AgentIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AgentID_Value:
					goto handle_Value

				case ffj_t_AgentIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *AgentInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AgentInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "hostname":`)
	fflib.WriteJsonString(buf, string(mj.Hostname))
	buf.WriteByte(',')
	if mj.Port != nil {
		if true {
			buf.WriteString(`"port":`)
			fflib.FormatBits2(buf, uint64(*mj.Port), 10, *mj.Port < 0)
			buf.WriteByte(',')
		}
	}
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Attributes) != 0 {
		buf.WriteString(`"attributes":`)
		if mj.Attributes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Attributes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Id != nil {
		if true {
			buf.WriteString(`"id":`)

			{

				err = mj.Id.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AgentInfobase = iota
	ffj_t_AgentInfono_such_key

	ffj_t_AgentInfo_Hostname

	ffj_t_AgentInfo_Port

	ffj_t_AgentInfo_Resources

	ffj_t_AgentInfo_Attributes

	ffj_t_AgentInfo_Id
)

var ffj_key_AgentInfo_Hostname = []byte("hostname")

var ffj_key_AgentInfo_Port = []byte("port")

var ffj_key_AgentInfo_Resources = []byte("resources")

var ffj_key_AgentInfo_Attributes = []byte("attributes")

var ffj_key_AgentInfo_Id = []byte("id")

func (uj *AgentInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AgentInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AgentInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AgentInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_AgentInfo_Attributes, kn) {
						currentKey = ffj_t_AgentInfo_Attributes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_AgentInfo_Hostname, kn) {
						currentKey = ffj_t_AgentInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_AgentInfo_Id, kn) {
						currentKey = ffj_t_AgentInfo_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AgentInfo_Port, kn) {
						currentKey = ffj_t_AgentInfo_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_AgentInfo_Resources, kn) {
						currentKey = ffj_t_AgentInfo_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AgentInfo_Id, kn) {
					currentKey = ffj_t_AgentInfo_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Attributes, kn) {
					currentKey = ffj_t_AgentInfo_Attributes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Resources, kn) {
					currentKey = ffj_t_AgentInfo_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AgentInfo_Port, kn) {
					currentKey = ffj_t_AgentInfo_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AgentInfo_Hostname, kn) {
					currentKey = ffj_t_AgentInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AgentInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AgentInfo_Hostname:
					goto handle_Hostname

				case ffj_t_AgentInfo_Port:
					goto handle_Port

				case ffj_t_AgentInfo_Resources:
					goto handle_Resources

				case ffj_t_AgentInfo_Attributes:
					goto handle_Attributes

				case ffj_t_AgentInfo_Id:
					goto handle_Id

				case ffj_t_AgentInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Hostname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Port = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.Port = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attributes:

	/* handler: uj.Attributes type=[]*mesos.Attribute kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attributes = nil
		} else {

			uj.Attributes = make([]*Attribute, 0)

			wantVal := true

			for {

				var v *Attribute

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Attribute kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Attribute)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attributes = append(uj.Attributes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Id:

	/* handler: uj.Id type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Id = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Id == nil {
			uj.Id = new(AgentID)
		}

		err = uj.Id.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Attribute) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Attribute) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Scalar != nil {
		if true {
			buf.WriteString(`"scalar":`)

			{

				err = mj.Scalar.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Ranges != nil {
		if true {
			buf.WriteString(`"ranges":`)

			{

				err = mj.Ranges.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Set != nil {
		if true {
			buf.WriteString(`"set":`)

			{

				err = mj.Set.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Text != nil {
		if true {
			buf.WriteString(`"text":`)

			{

				err = mj.Text.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Attributebase = iota
	ffj_t_Attributeno_such_key

	ffj_t_Attribute_Name

	ffj_t_Attribute_Type

	ffj_t_Attribute_Scalar

	ffj_t_Attribute_Ranges

	ffj_t_Attribute_Set

	ffj_t_Attribute_Text
)

var ffj_key_Attribute_Name = []byte("name")

var ffj_key_Attribute_Type = []byte("type")

var ffj_key_Attribute_Scalar = []byte("scalar")

var ffj_key_Attribute_Ranges = []byte("ranges")

var ffj_key_Attribute_Set = []byte("set")

var ffj_key_Attribute_Text = []byte("text")

func (uj *Attribute) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Attribute) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Attributebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Attributeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_Attribute_Name, kn) {
						currentKey = ffj_t_Attribute_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Attribute_Ranges, kn) {
						currentKey = ffj_t_Attribute_Ranges
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Attribute_Scalar, kn) {
						currentKey = ffj_t_Attribute_Scalar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Attribute_Set, kn) {
						currentKey = ffj_t_Attribute_Set
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Attribute_Type, kn) {
						currentKey = ffj_t_Attribute_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Attribute_Text, kn) {
						currentKey = ffj_t_Attribute_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Attribute_Text, kn) {
					currentKey = ffj_t_Attribute_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Attribute_Set, kn) {
					currentKey = ffj_t_Attribute_Set
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Attribute_Ranges, kn) {
					currentKey = ffj_t_Attribute_Ranges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Attribute_Scalar, kn) {
					currentKey = ffj_t_Attribute_Scalar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Attribute_Type, kn) {
					currentKey = ffj_t_Attribute_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Attribute_Name, kn) {
					currentKey = ffj_t_Attribute_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Attributeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Attribute_Name:
					goto handle_Name

				case ffj_t_Attribute_Type:
					goto handle_Type

				case ffj_t_Attribute_Scalar:
					goto handle_Scalar

				case ffj_t_Attribute_Ranges:
					goto handle_Ranges

				case ffj_t_Attribute_Set:
					goto handle_Set

				case ffj_t_Attribute_Text:
					goto handle_Text

				case ffj_t_Attributeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=mesos.Value_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Value_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scalar:

	/* handler: uj.Scalar type=mesos.Value_Scalar kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Scalar = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Scalar == nil {
			uj.Scalar = new(Value_Scalar)
		}

		err = uj.Scalar.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ranges:

	/* handler: uj.Ranges type=mesos.Value_Ranges kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ranges = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ranges == nil {
			uj.Ranges = new(Value_Ranges)
		}

		err = uj.Ranges.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Set:

	/* handler: uj.Set type=mesos.Value_Set kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Set = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Set == nil {
			uj.Set = new(Value_Set)
		}

		err = uj.Set.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=mesos.Value_Text kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Text = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Text == nil {
			uj.Text = new(Value_Text)
		}

		err = uj.Text.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CommandInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CommandInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Uris) != 0 {
		buf.WriteString(`"uris":`)
		if mj.Uris != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Uris {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Environment != nil {
		if true {
			buf.WriteString(`"environment":`)

			{

				err = mj.Environment.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Shell != nil {
		if true {
			if *mj.Shell {
				buf.WriteString(`"shell":true`)
			} else {
				buf.WriteString(`"shell":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Value != nil {
		if true {
			buf.WriteString(`"value":`)
			fflib.WriteJsonString(buf, string(*mj.Value))
			buf.WriteByte(',')
		}
	}
	if len(mj.Arguments) != 0 {
		buf.WriteString(`"arguments":`)
		if mj.Arguments != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Arguments {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.User != nil {
		if true {
			buf.WriteString(`"user":`)
			fflib.WriteJsonString(buf, string(*mj.User))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CommandInfobase = iota
	ffj_t_CommandInfono_such_key

	ffj_t_CommandInfo_Container

	ffj_t_CommandInfo_Uris

	ffj_t_CommandInfo_Environment

	ffj_t_CommandInfo_Shell

	ffj_t_CommandInfo_Value

	ffj_t_CommandInfo_Arguments

	ffj_t_CommandInfo_User
)

var ffj_key_CommandInfo_Container = []byte("container")

var ffj_key_CommandInfo_Uris = []byte("uris")

var ffj_key_CommandInfo_Environment = []byte("environment")

var ffj_key_CommandInfo_Shell = []byte("shell")

var ffj_key_CommandInfo_Value = []byte("value")

var ffj_key_CommandInfo_Arguments = []byte("arguments")

var ffj_key_CommandInfo_User = []byte("user")

func (uj *CommandInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CommandInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CommandInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CommandInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_CommandInfo_Arguments, kn) {
						currentKey = ffj_t_CommandInfo_Arguments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CommandInfo_Container, kn) {
						currentKey = ffj_t_CommandInfo_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_CommandInfo_Environment, kn) {
						currentKey = ffj_t_CommandInfo_Environment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_CommandInfo_Shell, kn) {
						currentKey = ffj_t_CommandInfo_Shell
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_CommandInfo_Uris, kn) {
						currentKey = ffj_t_CommandInfo_Uris
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CommandInfo_User, kn) {
						currentKey = ffj_t_CommandInfo_User
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_CommandInfo_Value, kn) {
						currentKey = ffj_t_CommandInfo_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_User, kn) {
					currentKey = ffj_t_CommandInfo_User
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_Arguments, kn) {
					currentKey = ffj_t_CommandInfo_Arguments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_Value, kn) {
					currentKey = ffj_t_CommandInfo_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_Shell, kn) {
					currentKey = ffj_t_CommandInfo_Shell
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_Environment, kn) {
					currentKey = ffj_t_CommandInfo_Environment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_Uris, kn) {
					currentKey = ffj_t_CommandInfo_Uris
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_Container, kn) {
					currentKey = ffj_t_CommandInfo_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CommandInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CommandInfo_Container:
					goto handle_Container

				case ffj_t_CommandInfo_Uris:
					goto handle_Uris

				case ffj_t_CommandInfo_Environment:
					goto handle_Environment

				case ffj_t_CommandInfo_Shell:
					goto handle_Shell

				case ffj_t_CommandInfo_Value:
					goto handle_Value

				case ffj_t_CommandInfo_Arguments:
					goto handle_Arguments

				case ffj_t_CommandInfo_User:
					goto handle_User

				case ffj_t_CommandInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Container:

	/* handler: uj.Container type=mesos.CommandInfo_ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(CommandInfo_ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uris:

	/* handler: uj.Uris type=[]*mesos.CommandInfo_URI kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Uris = nil
		} else {

			uj.Uris = make([]*CommandInfo_URI, 0)

			wantVal := true

			for {

				var v *CommandInfo_URI

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.CommandInfo_URI kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(CommandInfo_URI)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Uris = append(uj.Uris, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Environment:

	/* handler: uj.Environment type=mesos.Environment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Environment = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Environment == nil {
			uj.Environment = new(Environment)
		}

		err = uj.Environment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Shell:

	/* handler: uj.Shell type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Shell = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Shell = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Value = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Value = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arguments:

	/* handler: uj.Arguments type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Arguments = nil
		} else {

			uj.Arguments = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Arguments = append(uj.Arguments, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: uj.User type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.User = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.User = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CommandInfo_ContainerInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CommandInfo_ContainerInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "image":`)
	fflib.WriteJsonString(buf, string(mj.Image))
	buf.WriteByte(',')
	if len(mj.Options) != 0 {
		buf.WriteString(`"options":`)
		if mj.Options != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Options {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CommandInfo_ContainerInfobase = iota
	ffj_t_CommandInfo_ContainerInfono_such_key

	ffj_t_CommandInfo_ContainerInfo_Image

	ffj_t_CommandInfo_ContainerInfo_Options
)

var ffj_key_CommandInfo_ContainerInfo_Image = []byte("image")

var ffj_key_CommandInfo_ContainerInfo_Options = []byte("options")

func (uj *CommandInfo_ContainerInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CommandInfo_ContainerInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CommandInfo_ContainerInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CommandInfo_ContainerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_CommandInfo_ContainerInfo_Image, kn) {
						currentKey = ffj_t_CommandInfo_ContainerInfo_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_CommandInfo_ContainerInfo_Options, kn) {
						currentKey = ffj_t_CommandInfo_ContainerInfo_Options
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CommandInfo_ContainerInfo_Options, kn) {
					currentKey = ffj_t_CommandInfo_ContainerInfo_Options
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_ContainerInfo_Image, kn) {
					currentKey = ffj_t_CommandInfo_ContainerInfo_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CommandInfo_ContainerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CommandInfo_ContainerInfo_Image:
					goto handle_Image

				case ffj_t_CommandInfo_ContainerInfo_Options:
					goto handle_Options

				case ffj_t_CommandInfo_ContainerInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Options:

	/* handler: uj.Options type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Options = nil
		} else {

			uj.Options = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Options = append(uj.Options, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CommandInfo_URI) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CommandInfo_URI) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte(',')
	if mj.Executable != nil {
		if true {
			if *mj.Executable {
				buf.WriteString(`"executable":true`)
			} else {
				buf.WriteString(`"executable":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Extract != nil {
		if true {
			if *mj.Extract {
				buf.WriteString(`"extract":true`)
			} else {
				buf.WriteString(`"extract":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Cache != nil {
		if true {
			if *mj.Cache {
				buf.WriteString(`"cache":true`)
			} else {
				buf.WriteString(`"cache":false`)
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CommandInfo_URIbase = iota
	ffj_t_CommandInfo_URIno_such_key

	ffj_t_CommandInfo_URI_Value

	ffj_t_CommandInfo_URI_Executable

	ffj_t_CommandInfo_URI_Extract

	ffj_t_CommandInfo_URI_Cache
)

var ffj_key_CommandInfo_URI_Value = []byte("value")

var ffj_key_CommandInfo_URI_Executable = []byte("executable")

var ffj_key_CommandInfo_URI_Extract = []byte("extract")

var ffj_key_CommandInfo_URI_Cache = []byte("cache")

func (uj *CommandInfo_URI) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CommandInfo_URI) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CommandInfo_URIbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CommandInfo_URIno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CommandInfo_URI_Cache, kn) {
						currentKey = ffj_t_CommandInfo_URI_Cache
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_CommandInfo_URI_Executable, kn) {
						currentKey = ffj_t_CommandInfo_URI_Executable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CommandInfo_URI_Extract, kn) {
						currentKey = ffj_t_CommandInfo_URI_Extract
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_CommandInfo_URI_Value, kn) {
						currentKey = ffj_t_CommandInfo_URI_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Cache, kn) {
					currentKey = ffj_t_CommandInfo_URI_Cache
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Extract, kn) {
					currentKey = ffj_t_CommandInfo_URI_Extract
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Executable, kn) {
					currentKey = ffj_t_CommandInfo_URI_Executable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommandInfo_URI_Value, kn) {
					currentKey = ffj_t_CommandInfo_URI_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CommandInfo_URIno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CommandInfo_URI_Value:
					goto handle_Value

				case ffj_t_CommandInfo_URI_Executable:
					goto handle_Executable

				case ffj_t_CommandInfo_URI_Extract:
					goto handle_Extract

				case ffj_t_CommandInfo_URI_Cache:
					goto handle_Cache

				case ffj_t_CommandInfo_URIno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Executable:

	/* handler: uj.Executable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Executable = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Executable = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extract:

	/* handler: uj.Extract type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Extract = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Extract = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cache:

	/* handler: uj.Cache type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Cache = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Cache = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerIDbase = iota
	ffj_t_ContainerIDno_such_key

	ffj_t_ContainerID_Value
)

var ffj_key_ContainerID_Value = []byte("value")

func (uj *ContainerID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_ContainerID_Value, kn) {
						currentKey = ffj_t_ContainerID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerID_Value, kn) {
					currentKey = ffj_t_ContainerID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerID_Value:
					goto handle_Value

				case ffj_t_ContainerIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Volumes) != 0 {
		buf.WriteString(`"volumes":`)
		if mj.Volumes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Volumes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Docker != nil {
		if true {
			buf.WriteString(`"docker":`)

			{

				err = mj.Docker.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Mesos != nil {
		if true {
			buf.WriteString(`"mesos":`)

			{

				err = mj.Mesos.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfobase = iota
	ffj_t_ContainerInfono_such_key

	ffj_t_ContainerInfo_Type

	ffj_t_ContainerInfo_Volumes

	ffj_t_ContainerInfo_Hostname

	ffj_t_ContainerInfo_Docker

	ffj_t_ContainerInfo_Mesos
)

var ffj_key_ContainerInfo_Type = []byte("type")

var ffj_key_ContainerInfo_Volumes = []byte("volumes")

var ffj_key_ContainerInfo_Hostname = []byte("hostname")

var ffj_key_ContainerInfo_Docker = []byte("docker")

var ffj_key_ContainerInfo_Mesos = []byte("mesos")

func (uj *ContainerInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ContainerInfo_Docker, kn) {
						currentKey = ffj_t_ContainerInfo_Docker
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_ContainerInfo_Hostname, kn) {
						currentKey = ffj_t_ContainerInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ContainerInfo_Mesos, kn) {
						currentKey = ffj_t_ContainerInfo_Mesos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ContainerInfo_Type, kn) {
						currentKey = ffj_t_ContainerInfo_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_ContainerInfo_Volumes, kn) {
						currentKey = ffj_t_ContainerInfo_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Mesos, kn) {
					currentKey = ffj_t_ContainerInfo_Mesos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Docker, kn) {
					currentKey = ffj_t_ContainerInfo_Docker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Hostname, kn) {
					currentKey = ffj_t_ContainerInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_Volumes, kn) {
					currentKey = ffj_t_ContainerInfo_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_Type, kn) {
					currentKey = ffj_t_ContainerInfo_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_Type:
					goto handle_Type

				case ffj_t_ContainerInfo_Volumes:
					goto handle_Volumes

				case ffj_t_ContainerInfo_Hostname:
					goto handle_Hostname

				case ffj_t_ContainerInfo_Docker:
					goto handle_Docker

				case ffj_t_ContainerInfo_Mesos:
					goto handle_Mesos

				case ffj_t_ContainerInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.ContainerInfo_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(ContainerInfo_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Volumes:

	/* handler: uj.Volumes type=[]*mesos.Volume kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]*Volume, 0)

			wantVal := true

			for {

				var v *Volume

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Volume kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Volume)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Docker:

	/* handler: uj.Docker type=mesos.ContainerInfo_DockerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Docker = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Docker == nil {
			uj.Docker = new(ContainerInfo_DockerInfo)
		}

		err = uj.Docker.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mesos:

	/* handler: uj.Mesos type=mesos.ContainerInfo_MesosInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mesos = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Mesos == nil {
			uj.Mesos = new(ContainerInfo_MesosInfo)
		}

		err = uj.Mesos.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo_DockerInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo_DockerInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "image":`)
	fflib.WriteJsonString(buf, string(mj.Image))
	buf.WriteByte(',')
	if mj.Network != nil {
		if true {
			buf.WriteString(`"network":`)

			{

				obj, err = mj.Network.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.PortMappings) != 0 {
		buf.WriteString(`"port_mappings":`)
		if mj.PortMappings != nil {
			buf.WriteString(`[`)
			for i, v := range mj.PortMappings {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Privileged != nil {
		if true {
			if *mj.Privileged {
				buf.WriteString(`"privileged":true`)
			} else {
				buf.WriteString(`"privileged":false`)
			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Parameters) != 0 {
		buf.WriteString(`"parameters":`)
		if mj.Parameters != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Parameters {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.ForcePullImage != nil {
		if true {
			if *mj.ForcePullImage {
				buf.WriteString(`"force_pull_image":true`)
			} else {
				buf.WriteString(`"force_pull_image":false`)
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfo_DockerInfobase = iota
	ffj_t_ContainerInfo_DockerInfono_such_key

	ffj_t_ContainerInfo_DockerInfo_Image

	ffj_t_ContainerInfo_DockerInfo_Network

	ffj_t_ContainerInfo_DockerInfo_PortMappings

	ffj_t_ContainerInfo_DockerInfo_Privileged

	ffj_t_ContainerInfo_DockerInfo_Parameters

	ffj_t_ContainerInfo_DockerInfo_ForcePullImage
)

var ffj_key_ContainerInfo_DockerInfo_Image = []byte("image")

var ffj_key_ContainerInfo_DockerInfo_Network = []byte("network")

var ffj_key_ContainerInfo_DockerInfo_PortMappings = []byte("port_mappings")

var ffj_key_ContainerInfo_DockerInfo_Privileged = []byte("privileged")

var ffj_key_ContainerInfo_DockerInfo_Parameters = []byte("parameters")

var ffj_key_ContainerInfo_DockerInfo_ForcePullImage = []byte("force_pull_image")

func (uj *ContainerInfo_DockerInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo_DockerInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfo_DockerInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfo_DockerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_ForcePullImage, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_ForcePullImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Image, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Network, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Network
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMappings, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappings
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Privileged, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Privileged
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_Parameters, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_Parameters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ContainerInfo_DockerInfo_ForcePullImage, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_ForcePullImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_Parameters, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Parameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_DockerInfo_Privileged, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Privileged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_PortMappings, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_Network, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Network
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_DockerInfo_Image, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfo_DockerInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_DockerInfo_Image:
					goto handle_Image

				case ffj_t_ContainerInfo_DockerInfo_Network:
					goto handle_Network

				case ffj_t_ContainerInfo_DockerInfo_PortMappings:
					goto handle_PortMappings

				case ffj_t_ContainerInfo_DockerInfo_Privileged:
					goto handle_Privileged

				case ffj_t_ContainerInfo_DockerInfo_Parameters:
					goto handle_Parameters

				case ffj_t_ContainerInfo_DockerInfo_ForcePullImage:
					goto handle_ForcePullImage

				case ffj_t_ContainerInfo_DockerInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Image = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Network:

	/* handler: uj.Network type=mesos.ContainerInfo_DockerInfo_Network kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Network = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Network == nil {
			uj.Network = new(ContainerInfo_DockerInfo_Network)
		}

		err = uj.Network.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PortMappings:

	/* handler: uj.PortMappings type=[]*mesos.ContainerInfo_DockerInfo_PortMapping kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.PortMappings = nil
		} else {

			uj.PortMappings = make([]*ContainerInfo_DockerInfo_PortMapping, 0)

			wantVal := true

			for {

				var v *ContainerInfo_DockerInfo_PortMapping

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.ContainerInfo_DockerInfo_PortMapping kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(ContainerInfo_DockerInfo_PortMapping)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.PortMappings = append(uj.PortMappings, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Privileged:

	/* handler: uj.Privileged type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Privileged = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Privileged = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Parameters:

	/* handler: uj.Parameters type=[]*mesos.Parameter kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Parameters = nil
		} else {

			uj.Parameters = make([]*Parameter, 0)

			wantVal := true

			for {

				var v *Parameter

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Parameter kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Parameter)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Parameters = append(uj.Parameters, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForcePullImage:

	/* handler: uj.ForcePullImage type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.ForcePullImage = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.ForcePullImage = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo_DockerInfo_PortMapping) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo_DockerInfo_PortMapping) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "host_port":`)
	fflib.FormatBits2(buf, uint64(mj.HostPort), 10, false)
	buf.WriteString(`,"container_port":`)
	fflib.FormatBits2(buf, uint64(mj.ContainerPort), 10, false)
	buf.WriteByte(',')
	if mj.Protocol != nil {
		if true {
			buf.WriteString(`"protocol":`)
			fflib.WriteJsonString(buf, string(*mj.Protocol))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfo_DockerInfo_PortMappingbase = iota
	ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key

	ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort

	ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort

	ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol
)

var ffj_key_ContainerInfo_DockerInfo_PortMapping_HostPort = []byte("host_port")

var ffj_key_ContainerInfo_DockerInfo_PortMapping_ContainerPort = []byte("container_port")

var ffj_key_ContainerInfo_DockerInfo_PortMapping_Protocol = []byte("protocol")

func (uj *ContainerInfo_DockerInfo_PortMapping) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo_DockerInfo_PortMapping) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfo_DockerInfo_PortMappingbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMapping_ContainerPort, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMapping_HostPort, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ContainerInfo_DockerInfo_PortMapping_Protocol, kn) {
						currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_DockerInfo_PortMapping_Protocol, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ContainerInfo_DockerInfo_PortMapping_ContainerPort, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerInfo_DockerInfo_PortMapping_HostPort, kn) {
					currentKey = ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_DockerInfo_PortMapping_HostPort:
					goto handle_HostPort

				case ffj_t_ContainerInfo_DockerInfo_PortMapping_ContainerPort:
					goto handle_ContainerPort

				case ffj_t_ContainerInfo_DockerInfo_PortMapping_Protocol:
					goto handle_Protocol

				case ffj_t_ContainerInfo_DockerInfo_PortMappingno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_HostPort:

	/* handler: uj.HostPort type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HostPort = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerPort:

	/* handler: uj.ContainerPort type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ContainerPort = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Protocol = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Protocol = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerInfo_MesosInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerInfo_MesosInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Image != nil {
		if true {
			buf.WriteString(`"image":`)

			{

				err = mj.Image.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerInfo_MesosInfobase = iota
	ffj_t_ContainerInfo_MesosInfono_such_key

	ffj_t_ContainerInfo_MesosInfo_Image
)

var ffj_key_ContainerInfo_MesosInfo_Image = []byte("image")

func (uj *ContainerInfo_MesosInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerInfo_MesosInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerInfo_MesosInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerInfo_MesosInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ContainerInfo_MesosInfo_Image, kn) {
						currentKey = ffj_t_ContainerInfo_MesosInfo_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerInfo_MesosInfo_Image, kn) {
					currentKey = ffj_t_ContainerInfo_MesosInfo_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerInfo_MesosInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerInfo_MesosInfo_Image:
					goto handle_Image

				case ffj_t_ContainerInfo_MesosInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Image:

	/* handler: uj.Image type=mesos.Image kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Image = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Image == nil {
			uj.Image = new(Image)
		}

		err = uj.Image.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Credential) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Credential) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "principal":`)
	fflib.WriteJsonString(buf, string(mj.Principal))
	buf.WriteByte(',')
	if len(mj.Secret) != 0 {
		buf.WriteString(`"secret":`)
		if mj.Secret != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Secret)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Credentialbase = iota
	ffj_t_Credentialno_such_key

	ffj_t_Credential_Principal

	ffj_t_Credential_Secret
)

var ffj_key_Credential_Principal = []byte("principal")

var ffj_key_Credential_Secret = []byte("secret")

func (uj *Credential) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Credential) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Credentialbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Credentialno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Credential_Principal, kn) {
						currentKey = ffj_t_Credential_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Credential_Secret, kn) {
						currentKey = ffj_t_Credential_Secret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Credential_Secret, kn) {
					currentKey = ffj_t_Credential_Secret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Credential_Principal, kn) {
					currentKey = ffj_t_Credential_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Credentialno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Credential_Principal:
					goto handle_Principal

				case ffj_t_Credential_Secret:
					goto handle_Secret

				case ffj_t_Credentialno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Principal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: uj.Secret type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Secret = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Secret).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Credentials) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Credentials) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Credentials) != 0 {
		buf.WriteString(`"credentials":`)
		if mj.Credentials != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Credentials {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Credentialsbase = iota
	ffj_t_Credentialsno_such_key

	ffj_t_Credentials_Credentials
)

var ffj_key_Credentials_Credentials = []byte("credentials")

func (uj *Credentials) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Credentials) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Credentialsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Credentialsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Credentials_Credentials, kn) {
						currentKey = ffj_t_Credentials_Credentials
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Credentials_Credentials, kn) {
					currentKey = ffj_t_Credentials_Credentials
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Credentialsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Credentials_Credentials:
					goto handle_Credentials

				case ffj_t_Credentialsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Credentials:

	/* handler: uj.Credentials type=[]*mesos.Credential kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Credentials = nil
		} else {

			uj.Credentials = make([]*Credential, 0)

			wantVal := true

			for {

				var v *Credential

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Credential kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Credential)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Credentials = append(uj.Credentials, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *DiscoveryInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DiscoveryInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "visibility":`)

	{

		obj, err = mj.Visibility.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.Name != nil {
		if true {
			buf.WriteString(`"name":`)
			fflib.WriteJsonString(buf, string(*mj.Name))
			buf.WriteByte(',')
		}
	}
	if mj.Environment != nil {
		if true {
			buf.WriteString(`"environment":`)
			fflib.WriteJsonString(buf, string(*mj.Environment))
			buf.WriteByte(',')
		}
	}
	if mj.Location != nil {
		if true {
			buf.WriteString(`"location":`)
			fflib.WriteJsonString(buf, string(*mj.Location))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.WriteJsonString(buf, string(*mj.Version))
			buf.WriteByte(',')
		}
	}
	if mj.Ports != nil {
		if true {
			buf.WriteString(`"ports":`)

			{

				err = mj.Ports.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DiscoveryInfobase = iota
	ffj_t_DiscoveryInfono_such_key

	ffj_t_DiscoveryInfo_Visibility

	ffj_t_DiscoveryInfo_Name

	ffj_t_DiscoveryInfo_Environment

	ffj_t_DiscoveryInfo_Location

	ffj_t_DiscoveryInfo_Version

	ffj_t_DiscoveryInfo_Ports

	ffj_t_DiscoveryInfo_Labels
)

var ffj_key_DiscoveryInfo_Visibility = []byte("visibility")

var ffj_key_DiscoveryInfo_Name = []byte("name")

var ffj_key_DiscoveryInfo_Environment = []byte("environment")

var ffj_key_DiscoveryInfo_Location = []byte("location")

var ffj_key_DiscoveryInfo_Version = []byte("version")

var ffj_key_DiscoveryInfo_Ports = []byte("ports")

var ffj_key_DiscoveryInfo_Labels = []byte("labels")

func (uj *DiscoveryInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DiscoveryInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DiscoveryInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DiscoveryInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_DiscoveryInfo_Environment, kn) {
						currentKey = ffj_t_DiscoveryInfo_Environment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_DiscoveryInfo_Location, kn) {
						currentKey = ffj_t_DiscoveryInfo_Location
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DiscoveryInfo_Labels, kn) {
						currentKey = ffj_t_DiscoveryInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_DiscoveryInfo_Name, kn) {
						currentKey = ffj_t_DiscoveryInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_DiscoveryInfo_Ports, kn) {
						currentKey = ffj_t_DiscoveryInfo_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_DiscoveryInfo_Visibility, kn) {
						currentKey = ffj_t_DiscoveryInfo_Visibility
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_DiscoveryInfo_Version, kn) {
						currentKey = ffj_t_DiscoveryInfo_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Labels, kn) {
					currentKey = ffj_t_DiscoveryInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Ports, kn) {
					currentKey = ffj_t_DiscoveryInfo_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Version, kn) {
					currentKey = ffj_t_DiscoveryInfo_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DiscoveryInfo_Location, kn) {
					currentKey = ffj_t_DiscoveryInfo_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DiscoveryInfo_Environment, kn) {
					currentKey = ffj_t_DiscoveryInfo_Environment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_DiscoveryInfo_Name, kn) {
					currentKey = ffj_t_DiscoveryInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DiscoveryInfo_Visibility, kn) {
					currentKey = ffj_t_DiscoveryInfo_Visibility
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DiscoveryInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DiscoveryInfo_Visibility:
					goto handle_Visibility

				case ffj_t_DiscoveryInfo_Name:
					goto handle_Name

				case ffj_t_DiscoveryInfo_Environment:
					goto handle_Environment

				case ffj_t_DiscoveryInfo_Location:
					goto handle_Location

				case ffj_t_DiscoveryInfo_Version:
					goto handle_Version

				case ffj_t_DiscoveryInfo_Ports:
					goto handle_Ports

				case ffj_t_DiscoveryInfo_Labels:
					goto handle_Labels

				case ffj_t_DiscoveryInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Visibility:

	/* handler: uj.Visibility type=mesos.DiscoveryInfo_Visibility kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Visibility.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Name = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Name = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Environment:

	/* handler: uj.Environment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Environment = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Environment = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Location = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Location = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Version = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ports:

	/* handler: uj.Ports type=mesos.Ports kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ports = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ports == nil {
			uj.Ports = new(Ports)
		}

		err = uj.Ports.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *DurationInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DurationInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"nanoseconds":`)
	fflib.FormatBits2(buf, uint64(mj.Nanoseconds), 10, mj.Nanoseconds < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DurationInfobase = iota
	ffj_t_DurationInfono_such_key

	ffj_t_DurationInfo_Nanoseconds
)

var ffj_key_DurationInfo_Nanoseconds = []byte("nanoseconds")

func (uj *DurationInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DurationInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DurationInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DurationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_DurationInfo_Nanoseconds, kn) {
						currentKey = ffj_t_DurationInfo_Nanoseconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_DurationInfo_Nanoseconds, kn) {
					currentKey = ffj_t_DurationInfo_Nanoseconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DurationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DurationInfo_Nanoseconds:
					goto handle_Nanoseconds

				case ffj_t_DurationInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Nanoseconds:

	/* handler: uj.Nanoseconds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Nanoseconds = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Environment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Environment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Variables) != 0 {
		buf.WriteString(`"variables":`)
		if mj.Variables != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Variables {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Environmentbase = iota
	ffj_t_Environmentno_such_key

	ffj_t_Environment_Variables
)

var ffj_key_Environment_Variables = []byte("variables")

func (uj *Environment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Environment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Environmentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Environmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Environment_Variables, kn) {
						currentKey = ffj_t_Environment_Variables
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Environment_Variables, kn) {
					currentKey = ffj_t_Environment_Variables
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Environmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Environment_Variables:
					goto handle_Variables

				case ffj_t_Environmentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Variables:

	/* handler: uj.Variables type=[]*mesos.Environment_Variable kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Variables = nil
		} else {

			uj.Variables = make([]*Environment_Variable, 0)

			wantVal := true

			for {

				var v *Environment_Variable

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Environment_Variable kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Environment_Variable)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Variables = append(uj.Variables, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Environment_Variable) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Environment_Variable) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Environment_Variablebase = iota
	ffj_t_Environment_Variableno_such_key

	ffj_t_Environment_Variable_Name

	ffj_t_Environment_Variable_Value
)

var ffj_key_Environment_Variable_Name = []byte("name")

var ffj_key_Environment_Variable_Value = []byte("value")

func (uj *Environment_Variable) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Environment_Variable) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Environment_Variablebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Environment_Variableno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_Environment_Variable_Name, kn) {
						currentKey = ffj_t_Environment_Variable_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Environment_Variable_Value, kn) {
						currentKey = ffj_t_Environment_Variable_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Environment_Variable_Value, kn) {
					currentKey = ffj_t_Environment_Variable_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Environment_Variable_Name, kn) {
					currentKey = ffj_t_Environment_Variable_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Environment_Variableno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Environment_Variable_Name:
					goto handle_Name

				case ffj_t_Environment_Variable_Value:
					goto handle_Value

				case ffj_t_Environment_Variableno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ExecutorID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ExecutorID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ExecutorIDbase = iota
	ffj_t_ExecutorIDno_such_key

	ffj_t_ExecutorID_Value
)

var ffj_key_ExecutorID_Value = []byte("value")

func (uj *ExecutorID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ExecutorID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ExecutorIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ExecutorIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_ExecutorID_Value, kn) {
						currentKey = ffj_t_ExecutorID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorID_Value, kn) {
					currentKey = ffj_t_ExecutorID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ExecutorIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ExecutorID_Value:
					goto handle_Value

				case ffj_t_ExecutorIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ExecutorInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ExecutorInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "executor_id":`)

	{

		err = mj.ExecutorId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.FrameworkId != nil {
		if true {
			buf.WriteString(`"framework_id":`)

			{

				err = mj.FrameworkId.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"command":`)

	{

		err = mj.Command.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Name != nil {
		if true {
			buf.WriteString(`"name":`)
			fflib.WriteJsonString(buf, string(*mj.Name))
			buf.WriteByte(',')
		}
	}
	if mj.Source != nil {
		if true {
			buf.WriteString(`"source":`)
			fflib.WriteJsonString(buf, string(*mj.Source))
			buf.WriteByte(',')
		}
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Discovery != nil {
		if true {
			buf.WriteString(`"discovery":`)

			{

				err = mj.Discovery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ExecutorInfobase = iota
	ffj_t_ExecutorInfono_such_key

	ffj_t_ExecutorInfo_ExecutorId

	ffj_t_ExecutorInfo_FrameworkId

	ffj_t_ExecutorInfo_Command

	ffj_t_ExecutorInfo_Container

	ffj_t_ExecutorInfo_Resources

	ffj_t_ExecutorInfo_Name

	ffj_t_ExecutorInfo_Source

	ffj_t_ExecutorInfo_Data

	ffj_t_ExecutorInfo_Discovery
)

var ffj_key_ExecutorInfo_ExecutorId = []byte("executor_id")

var ffj_key_ExecutorInfo_FrameworkId = []byte("framework_id")

var ffj_key_ExecutorInfo_Command = []byte("command")

var ffj_key_ExecutorInfo_Container = []byte("container")

var ffj_key_ExecutorInfo_Resources = []byte("resources")

var ffj_key_ExecutorInfo_Name = []byte("name")

var ffj_key_ExecutorInfo_Source = []byte("source")

var ffj_key_ExecutorInfo_Data = []byte("data")

var ffj_key_ExecutorInfo_Discovery = []byte("discovery")

func (uj *ExecutorInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ExecutorInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ExecutorInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ExecutorInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ExecutorInfo_Command, kn) {
						currentKey = ffj_t_ExecutorInfo_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExecutorInfo_Container, kn) {
						currentKey = ffj_t_ExecutorInfo_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ExecutorInfo_Data, kn) {
						currentKey = ffj_t_ExecutorInfo_Data
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ExecutorInfo_Discovery, kn) {
						currentKey = ffj_t_ExecutorInfo_Discovery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ExecutorInfo_ExecutorId, kn) {
						currentKey = ffj_t_ExecutorInfo_ExecutorId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ExecutorInfo_FrameworkId, kn) {
						currentKey = ffj_t_ExecutorInfo_FrameworkId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ExecutorInfo_Name, kn) {
						currentKey = ffj_t_ExecutorInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ExecutorInfo_Resources, kn) {
						currentKey = ffj_t_ExecutorInfo_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ExecutorInfo_Source, kn) {
						currentKey = ffj_t_ExecutorInfo_Source
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_Discovery, kn) {
					currentKey = ffj_t_ExecutorInfo_Discovery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Data, kn) {
					currentKey = ffj_t_ExecutorInfo_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_Source, kn) {
					currentKey = ffj_t_ExecutorInfo_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Name, kn) {
					currentKey = ffj_t_ExecutorInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_Resources, kn) {
					currentKey = ffj_t_ExecutorInfo_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Container, kn) {
					currentKey = ffj_t_ExecutorInfo_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecutorInfo_Command, kn) {
					currentKey = ffj_t_ExecutorInfo_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ExecutorInfo_FrameworkId, kn) {
					currentKey = ffj_t_ExecutorInfo_FrameworkId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ExecutorInfo_ExecutorId, kn) {
					currentKey = ffj_t_ExecutorInfo_ExecutorId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ExecutorInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ExecutorInfo_ExecutorId:
					goto handle_ExecutorId

				case ffj_t_ExecutorInfo_FrameworkId:
					goto handle_FrameworkId

				case ffj_t_ExecutorInfo_Command:
					goto handle_Command

				case ffj_t_ExecutorInfo_Container:
					goto handle_Container

				case ffj_t_ExecutorInfo_Resources:
					goto handle_Resources

				case ffj_t_ExecutorInfo_Name:
					goto handle_Name

				case ffj_t_ExecutorInfo_Source:
					goto handle_Source

				case ffj_t_ExecutorInfo_Data:
					goto handle_Data

				case ffj_t_ExecutorInfo_Discovery:
					goto handle_Discovery

				case ffj_t_ExecutorInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExecutorId:

	/* handler: uj.ExecutorId type=mesos.ExecutorID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ExecutorId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrameworkId:

	/* handler: uj.FrameworkId type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.FrameworkId = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.FrameworkId == nil {
			uj.FrameworkId = new(FrameworkID)
		}

		err = uj.FrameworkId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Name = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Name = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Source = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Source = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Discovery:

	/* handler: uj.Discovery type=mesos.DiscoveryInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Discovery = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Discovery == nil {
			uj.Discovery = new(DiscoveryInfo)
		}

		err = uj.Discovery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Filters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Filters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.RefuseSeconds != nil {
		if true {
			buf.WriteString(`"refuse_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.RefuseSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Filtersbase = iota
	ffj_t_Filtersno_such_key

	ffj_t_Filters_RefuseSeconds
)

var ffj_key_Filters_RefuseSeconds = []byte("refuse_seconds")

func (uj *Filters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Filters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Filtersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Filtersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Filters_RefuseSeconds, kn) {
						currentKey = ffj_t_Filters_RefuseSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Filters_RefuseSeconds, kn) {
					currentKey = ffj_t_Filters_RefuseSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Filtersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Filters_RefuseSeconds:
					goto handle_RefuseSeconds

				case ffj_t_Filtersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RefuseSeconds:

	/* handler: uj.RefuseSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RefuseSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.RefuseSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FrameworkID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FrameworkID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FrameworkIDbase = iota
	ffj_t_FrameworkIDno_such_key

	ffj_t_FrameworkID_Value
)

var ffj_key_FrameworkID_Value = []byte("value")

func (uj *FrameworkID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FrameworkID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FrameworkIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FrameworkIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_FrameworkID_Value, kn) {
						currentKey = ffj_t_FrameworkID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkID_Value, kn) {
					currentKey = ffj_t_FrameworkID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FrameworkIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FrameworkID_Value:
					goto handle_Value

				case ffj_t_FrameworkIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FrameworkInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FrameworkInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "user":`)
	fflib.WriteJsonString(buf, string(mj.User))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.ID != nil {
		if true {
			buf.WriteString(`"id":`)

			{

				err = mj.ID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.FailoverTimeout != nil {
		if true {
			buf.WriteString(`"failover_timeout":`)
			fflib.AppendFloat(buf, float64(*mj.FailoverTimeout), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.Checkpoint != nil {
		if true {
			if *mj.Checkpoint {
				buf.WriteString(`"checkpoint":true`)
			} else {
				buf.WriteString(`"checkpoint":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Role != nil {
		if true {
			buf.WriteString(`"role":`)
			fflib.WriteJsonString(buf, string(*mj.Role))
			buf.WriteByte(',')
		}
	}
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Principal != nil {
		if true {
			buf.WriteString(`"principal":`)
			fflib.WriteJsonString(buf, string(*mj.Principal))
			buf.WriteByte(',')
		}
	}
	if mj.WebuiUrl != nil {
		if true {
			buf.WriteString(`"webui_url":`)
			fflib.WriteJsonString(buf, string(*mj.WebuiUrl))
			buf.WriteByte(',')
		}
	}
	if len(mj.Capabilities) != 0 {
		buf.WriteString(`"capabilities":`)
		if mj.Capabilities != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Capabilities {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FrameworkInfobase = iota
	ffj_t_FrameworkInfono_such_key

	ffj_t_FrameworkInfo_User

	ffj_t_FrameworkInfo_Name

	ffj_t_FrameworkInfo_ID

	ffj_t_FrameworkInfo_FailoverTimeout

	ffj_t_FrameworkInfo_Checkpoint

	ffj_t_FrameworkInfo_Role

	ffj_t_FrameworkInfo_Hostname

	ffj_t_FrameworkInfo_Principal

	ffj_t_FrameworkInfo_WebuiUrl

	ffj_t_FrameworkInfo_Capabilities

	ffj_t_FrameworkInfo_Labels
)

var ffj_key_FrameworkInfo_User = []byte("user")

var ffj_key_FrameworkInfo_Name = []byte("name")

var ffj_key_FrameworkInfo_ID = []byte("id")

var ffj_key_FrameworkInfo_FailoverTimeout = []byte("failover_timeout")

var ffj_key_FrameworkInfo_Checkpoint = []byte("checkpoint")

var ffj_key_FrameworkInfo_Role = []byte("role")

var ffj_key_FrameworkInfo_Hostname = []byte("hostname")

var ffj_key_FrameworkInfo_Principal = []byte("principal")

var ffj_key_FrameworkInfo_WebuiUrl = []byte("webui_url")

var ffj_key_FrameworkInfo_Capabilities = []byte("capabilities")

var ffj_key_FrameworkInfo_Labels = []byte("labels")

func (uj *FrameworkInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FrameworkInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FrameworkInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FrameworkInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_FrameworkInfo_Checkpoint, kn) {
						currentKey = ffj_t_FrameworkInfo_Checkpoint
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FrameworkInfo_Capabilities, kn) {
						currentKey = ffj_t_FrameworkInfo_Capabilities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_FrameworkInfo_FailoverTimeout, kn) {
						currentKey = ffj_t_FrameworkInfo_FailoverTimeout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_FrameworkInfo_Hostname, kn) {
						currentKey = ffj_t_FrameworkInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_FrameworkInfo_ID, kn) {
						currentKey = ffj_t_FrameworkInfo_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_FrameworkInfo_Labels, kn) {
						currentKey = ffj_t_FrameworkInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_FrameworkInfo_Name, kn) {
						currentKey = ffj_t_FrameworkInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_FrameworkInfo_Principal, kn) {
						currentKey = ffj_t_FrameworkInfo_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_FrameworkInfo_Role, kn) {
						currentKey = ffj_t_FrameworkInfo_Role
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_FrameworkInfo_User, kn) {
						currentKey = ffj_t_FrameworkInfo_User
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_FrameworkInfo_WebuiUrl, kn) {
						currentKey = ffj_t_FrameworkInfo_WebuiUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Labels, kn) {
					currentKey = ffj_t_FrameworkInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Capabilities, kn) {
					currentKey = ffj_t_FrameworkInfo_Capabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_FrameworkInfo_WebuiUrl, kn) {
					currentKey = ffj_t_FrameworkInfo_WebuiUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Principal, kn) {
					currentKey = ffj_t_FrameworkInfo_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Hostname, kn) {
					currentKey = ffj_t_FrameworkInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Role, kn) {
					currentKey = ffj_t_FrameworkInfo_Role
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_Checkpoint, kn) {
					currentKey = ffj_t_FrameworkInfo_Checkpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_FrameworkInfo_FailoverTimeout, kn) {
					currentKey = ffj_t_FrameworkInfo_FailoverTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_ID, kn) {
					currentKey = ffj_t_FrameworkInfo_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Name, kn) {
					currentKey = ffj_t_FrameworkInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FrameworkInfo_User, kn) {
					currentKey = ffj_t_FrameworkInfo_User
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FrameworkInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FrameworkInfo_User:
					goto handle_User

				case ffj_t_FrameworkInfo_Name:
					goto handle_Name

				case ffj_t_FrameworkInfo_ID:
					goto handle_ID

				case ffj_t_FrameworkInfo_FailoverTimeout:
					goto handle_FailoverTimeout

				case ffj_t_FrameworkInfo_Checkpoint:
					goto handle_Checkpoint

				case ffj_t_FrameworkInfo_Role:
					goto handle_Role

				case ffj_t_FrameworkInfo_Hostname:
					goto handle_Hostname

				case ffj_t_FrameworkInfo_Principal:
					goto handle_Principal

				case ffj_t_FrameworkInfo_WebuiUrl:
					goto handle_WebuiUrl

				case ffj_t_FrameworkInfo_Capabilities:
					goto handle_Capabilities

				case ffj_t_FrameworkInfo_Labels:
					goto handle_Labels

				case ffj_t_FrameworkInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: uj.User type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.User = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ID == nil {
			uj.ID = new(FrameworkID)
		}

		err = uj.ID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FailoverTimeout:

	/* handler: uj.FailoverTimeout type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.FailoverTimeout = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.FailoverTimeout = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Checkpoint:

	/* handler: uj.Checkpoint type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Checkpoint = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Checkpoint = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: uj.Role type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Role = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Role = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Principal = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Principal = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebuiUrl:

	/* handler: uj.WebuiUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.WebuiUrl = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.WebuiUrl = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Capabilities:

	/* handler: uj.Capabilities type=[]*mesos.FrameworkInfo_Capability kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Capabilities = nil
		} else {

			uj.Capabilities = make([]*FrameworkInfo_Capability, 0)

			wantVal := true

			for {

				var v *FrameworkInfo_Capability

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.FrameworkInfo_Capability kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(FrameworkInfo_Capability)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Capabilities = append(uj.Capabilities, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FrameworkInfo_Capability) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FrameworkInfo_Capability) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FrameworkInfo_Capabilitybase = iota
	ffj_t_FrameworkInfo_Capabilityno_such_key

	ffj_t_FrameworkInfo_Capability_Type
)

var ffj_key_FrameworkInfo_Capability_Type = []byte("type")

func (uj *FrameworkInfo_Capability) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FrameworkInfo_Capability) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FrameworkInfo_Capabilitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FrameworkInfo_Capabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffj_key_FrameworkInfo_Capability_Type, kn) {
						currentKey = ffj_t_FrameworkInfo_Capability_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_FrameworkInfo_Capability_Type, kn) {
					currentKey = ffj_t_FrameworkInfo_Capability_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FrameworkInfo_Capabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FrameworkInfo_Capability_Type:
					goto handle_Type

				case ffj_t_FrameworkInfo_Capabilityno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.FrameworkInfo_Capability_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(FrameworkInfo_Capability_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *HealthCheck) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HealthCheck) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Http != nil {
		if true {
			buf.WriteString(`"http":`)

			{

				err = mj.Http.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.DelaySeconds != nil {
		if true {
			buf.WriteString(`"delay_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.DelaySeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.IntervalSeconds != nil {
		if true {
			buf.WriteString(`"interval_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.IntervalSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.TimeoutSeconds != nil {
		if true {
			buf.WriteString(`"timeout_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.TimeoutSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.ConsecutiveFailures != nil {
		if true {
			buf.WriteString(`"consecutive_failures":`)
			fflib.FormatBits2(buf, uint64(*mj.ConsecutiveFailures), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.GracePeriodSeconds != nil {
		if true {
			buf.WriteString(`"grace_period_seconds":`)
			fflib.AppendFloat(buf, float64(*mj.GracePeriodSeconds), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HealthCheckbase = iota
	ffj_t_HealthCheckno_such_key

	ffj_t_HealthCheck_Http

	ffj_t_HealthCheck_DelaySeconds

	ffj_t_HealthCheck_IntervalSeconds

	ffj_t_HealthCheck_TimeoutSeconds

	ffj_t_HealthCheck_ConsecutiveFailures

	ffj_t_HealthCheck_GracePeriodSeconds

	ffj_t_HealthCheck_Command
)

var ffj_key_HealthCheck_Http = []byte("http")

var ffj_key_HealthCheck_DelaySeconds = []byte("delay_seconds")

var ffj_key_HealthCheck_IntervalSeconds = []byte("interval_seconds")

var ffj_key_HealthCheck_TimeoutSeconds = []byte("timeout_seconds")

var ffj_key_HealthCheck_ConsecutiveFailures = []byte("consecutive_failures")

var ffj_key_HealthCheck_GracePeriodSeconds = []byte("grace_period_seconds")

var ffj_key_HealthCheck_Command = []byte("command")

func (uj *HealthCheck) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HealthCheck) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HealthCheckbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HealthCheckno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_HealthCheck_ConsecutiveFailures, kn) {
						currentKey = ffj_t_HealthCheck_ConsecutiveFailures
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HealthCheck_Command, kn) {
						currentKey = ffj_t_HealthCheck_Command
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_HealthCheck_DelaySeconds, kn) {
						currentKey = ffj_t_HealthCheck_DelaySeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_HealthCheck_GracePeriodSeconds, kn) {
						currentKey = ffj_t_HealthCheck_GracePeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_HealthCheck_Http, kn) {
						currentKey = ffj_t_HealthCheck_Http
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_HealthCheck_IntervalSeconds, kn) {
						currentKey = ffj_t_HealthCheck_IntervalSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_HealthCheck_TimeoutSeconds, kn) {
						currentKey = ffj_t_HealthCheck_TimeoutSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_Command, kn) {
					currentKey = ffj_t_HealthCheck_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_GracePeriodSeconds, kn) {
					currentKey = ffj_t_HealthCheck_GracePeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_ConsecutiveFailures, kn) {
					currentKey = ffj_t_HealthCheck_ConsecutiveFailures
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_TimeoutSeconds, kn) {
					currentKey = ffj_t_HealthCheck_TimeoutSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_IntervalSeconds, kn) {
					currentKey = ffj_t_HealthCheck_IntervalSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_DelaySeconds, kn) {
					currentKey = ffj_t_HealthCheck_DelaySeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_Http, kn) {
					currentKey = ffj_t_HealthCheck_Http
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HealthCheckno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HealthCheck_Http:
					goto handle_Http

				case ffj_t_HealthCheck_DelaySeconds:
					goto handle_DelaySeconds

				case ffj_t_HealthCheck_IntervalSeconds:
					goto handle_IntervalSeconds

				case ffj_t_HealthCheck_TimeoutSeconds:
					goto handle_TimeoutSeconds

				case ffj_t_HealthCheck_ConsecutiveFailures:
					goto handle_ConsecutiveFailures

				case ffj_t_HealthCheck_GracePeriodSeconds:
					goto handle_GracePeriodSeconds

				case ffj_t_HealthCheck_Command:
					goto handle_Command

				case ffj_t_HealthCheckno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Http:

	/* handler: uj.Http type=mesos.HealthCheck_HTTP kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Http = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Http == nil {
			uj.Http = new(HealthCheck_HTTP)
		}

		err = uj.Http.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DelaySeconds:

	/* handler: uj.DelaySeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DelaySeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.DelaySeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IntervalSeconds:

	/* handler: uj.IntervalSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.IntervalSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.IntervalSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeoutSeconds:

	/* handler: uj.TimeoutSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.TimeoutSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.TimeoutSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConsecutiveFailures:

	/* handler: uj.ConsecutiveFailures type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ConsecutiveFailures = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.ConsecutiveFailures = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GracePeriodSeconds:

	/* handler: uj.GracePeriodSeconds type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.GracePeriodSeconds = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.GracePeriodSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *HealthCheck_HTTP) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HealthCheck_HTTP) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "port":`)
	fflib.FormatBits2(buf, uint64(mj.Port), 10, false)
	buf.WriteByte(',')
	if mj.Path != nil {
		if true {
			buf.WriteString(`"path":`)
			fflib.WriteJsonString(buf, string(*mj.Path))
			buf.WriteByte(',')
		}
	}
	if len(mj.Statuses) != 0 {
		buf.WriteString(`"statuses":`)
		if mj.Statuses != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Statuses {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.FormatBits2(buf, uint64(v), 10, false)
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HealthCheck_HTTPbase = iota
	ffj_t_HealthCheck_HTTPno_such_key

	ffj_t_HealthCheck_HTTP_Port

	ffj_t_HealthCheck_HTTP_Path

	ffj_t_HealthCheck_HTTP_Statuses
)

var ffj_key_HealthCheck_HTTP_Port = []byte("port")

var ffj_key_HealthCheck_HTTP_Path = []byte("path")

var ffj_key_HealthCheck_HTTP_Statuses = []byte("statuses")

func (uj *HealthCheck_HTTP) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HealthCheck_HTTP) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HealthCheck_HTTPbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HealthCheck_HTTPno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_HealthCheck_HTTP_Port, kn) {
						currentKey = ffj_t_HealthCheck_HTTP_Port
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HealthCheck_HTTP_Path, kn) {
						currentKey = ffj_t_HealthCheck_HTTP_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_HealthCheck_HTTP_Statuses, kn) {
						currentKey = ffj_t_HealthCheck_HTTP_Statuses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_HealthCheck_HTTP_Statuses, kn) {
					currentKey = ffj_t_HealthCheck_HTTP_Statuses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_HTTP_Path, kn) {
					currentKey = ffj_t_HealthCheck_HTTP_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HealthCheck_HTTP_Port, kn) {
					currentKey = ffj_t_HealthCheck_HTTP_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HealthCheck_HTTPno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HealthCheck_HTTP_Port:
					goto handle_Port

				case ffj_t_HealthCheck_HTTP_Path:
					goto handle_Path

				case ffj_t_HealthCheck_HTTP_Statuses:
					goto handle_Statuses

				case ffj_t_HealthCheck_HTTPno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Port:

	/* handler: uj.Port type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Port = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Path = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Path = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Statuses:

	/* handler: uj.Statuses type=[]uint32 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Statuses = nil
		} else {

			uj.Statuses = make([]uint32, 0)

			wantVal := true

			for {

				var v uint32

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=uint32 kind=uint32 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

						if err != nil {
							return fs.WrapErr(err)
						}

						v = uint32(tval)

					}
				}

				uj.Statuses = append(uj.Statuses, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Image) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Image) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Appc != nil {
		if true {
			buf.WriteString(`"appc":`)

			{

				err = mj.Appc.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Imagebase = iota
	ffj_t_Imageno_such_key

	ffj_t_Image_Type

	ffj_t_Image_Appc
)

var ffj_key_Image_Type = []byte("type")

var ffj_key_Image_Appc = []byte("appc")

func (uj *Image) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Image) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Imagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Imageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Image_Appc, kn) {
						currentKey = ffj_t_Image_Appc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Image_Type, kn) {
						currentKey = ffj_t_Image_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Appc, kn) {
					currentKey = ffj_t_Image_Appc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_Type, kn) {
					currentKey = ffj_t_Image_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Imageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Image_Type:
					goto handle_Type

				case ffj_t_Image_Appc:
					goto handle_Appc

				case ffj_t_Imageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Image_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Image_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Appc:

	/* handler: uj.Appc type=mesos.Image_AppC kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Appc = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Appc == nil {
			uj.Appc = new(Image_AppC)
		}

		err = uj.Appc.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Image_AppC) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Image_AppC) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.Id))
	buf.WriteByte(',')
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Image_AppCbase = iota
	ffj_t_Image_AppCno_such_key

	ffj_t_Image_AppC_Name

	ffj_t_Image_AppC_Id

	ffj_t_Image_AppC_Labels
)

var ffj_key_Image_AppC_Name = []byte("name")

var ffj_key_Image_AppC_Id = []byte("id")

var ffj_key_Image_AppC_Labels = []byte("labels")

func (uj *Image_AppC) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Image_AppC) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Image_AppCbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Image_AppCno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Image_AppC_Id, kn) {
						currentKey = ffj_t_Image_AppC_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Image_AppC_Labels, kn) {
						currentKey = ffj_t_Image_AppC_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Image_AppC_Name, kn) {
						currentKey = ffj_t_Image_AppC_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Image_AppC_Labels, kn) {
					currentKey = ffj_t_Image_AppC_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_AppC_Id, kn) {
					currentKey = ffj_t_Image_AppC_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Image_AppC_Name, kn) {
					currentKey = ffj_t_Image_AppC_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Image_AppCno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Image_AppC_Name:
					goto handle_Name

				case ffj_t_Image_AppC_Id:
					goto handle_Id

				case ffj_t_Image_AppC_Labels:
					goto handle_Labels

				case ffj_t_Image_AppCno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Id:

	/* handler: uj.Id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *InverseOffer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InverseOffer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		err = mj.OfferID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Url != nil {
		if true {
			buf.WriteString(`"url":`)

			{

				err = mj.Url.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"framework_id":`)

	{

		err = mj.FrameworkId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.AgentId != nil {
		if true {
			buf.WriteString(`"agent_id":`)

			{

				err = mj.AgentId.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"unavailability":`)

	{

		err = mj.Unavailability.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InverseOfferbase = iota
	ffj_t_InverseOfferno_such_key

	ffj_t_InverseOffer_OfferID

	ffj_t_InverseOffer_Url

	ffj_t_InverseOffer_FrameworkId

	ffj_t_InverseOffer_AgentId

	ffj_t_InverseOffer_Unavailability

	ffj_t_InverseOffer_Resources
)

var ffj_key_InverseOffer_OfferID = []byte("id")

var ffj_key_InverseOffer_Url = []byte("url")

var ffj_key_InverseOffer_FrameworkId = []byte("framework_id")

var ffj_key_InverseOffer_AgentId = []byte("agent_id")

var ffj_key_InverseOffer_Unavailability = []byte("unavailability")

var ffj_key_InverseOffer_Resources = []byte("resources")

func (uj *InverseOffer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InverseOffer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InverseOfferbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InverseOfferno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_InverseOffer_AgentId, kn) {
						currentKey = ffj_t_InverseOffer_AgentId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_InverseOffer_FrameworkId, kn) {
						currentKey = ffj_t_InverseOffer_FrameworkId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InverseOffer_OfferID, kn) {
						currentKey = ffj_t_InverseOffer_OfferID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InverseOffer_Resources, kn) {
						currentKey = ffj_t_InverseOffer_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_InverseOffer_Url, kn) {
						currentKey = ffj_t_InverseOffer_Url
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InverseOffer_Unavailability, kn) {
						currentKey = ffj_t_InverseOffer_Unavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InverseOffer_Resources, kn) {
					currentKey = ffj_t_InverseOffer_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InverseOffer_Unavailability, kn) {
					currentKey = ffj_t_InverseOffer_Unavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InverseOffer_AgentId, kn) {
					currentKey = ffj_t_InverseOffer_AgentId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InverseOffer_FrameworkId, kn) {
					currentKey = ffj_t_InverseOffer_FrameworkId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InverseOffer_Url, kn) {
					currentKey = ffj_t_InverseOffer_Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InverseOffer_OfferID, kn) {
					currentKey = ffj_t_InverseOffer_OfferID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InverseOfferno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InverseOffer_OfferID:
					goto handle_OfferID

				case ffj_t_InverseOffer_Url:
					goto handle_Url

				case ffj_t_InverseOffer_FrameworkId:
					goto handle_FrameworkId

				case ffj_t_InverseOffer_AgentId:
					goto handle_AgentId

				case ffj_t_InverseOffer_Unavailability:
					goto handle_Unavailability

				case ffj_t_InverseOffer_Resources:
					goto handle_Resources

				case ffj_t_InverseOfferno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OfferID:

	/* handler: uj.OfferID type=mesos.OfferID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.OfferID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Url:

	/* handler: uj.Url type=mesos.URL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Url = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Url == nil {
			uj.Url = new(URL)
		}

		err = uj.Url.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrameworkId:

	/* handler: uj.FrameworkId type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.FrameworkId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentId:

	/* handler: uj.AgentId type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentId = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentId == nil {
			uj.AgentId = new(AgentID)
		}

		err = uj.AgentId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailability:

	/* handler: uj.Unavailability type=mesos.Unavailability kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Unavailability.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Label) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Label) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "key":`)
	fflib.WriteJsonString(buf, string(mj.Key))
	buf.WriteByte(',')
	if mj.Value != nil {
		if true {
			buf.WriteString(`"value":`)
			fflib.WriteJsonString(buf, string(*mj.Value))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Labelbase = iota
	ffj_t_Labelno_such_key

	ffj_t_Label_Key

	ffj_t_Label_Value
)

var ffj_key_Label_Key = []byte("key")

var ffj_key_Label_Value = []byte("value")

func (uj *Label) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Label) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Labelbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Labelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffj_key_Label_Key, kn) {
						currentKey = ffj_t_Label_Key
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Label_Value, kn) {
						currentKey = ffj_t_Label_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Label_Value, kn) {
					currentKey = ffj_t_Label_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Label_Key, kn) {
					currentKey = ffj_t_Label_Key
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Labelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Label_Key:
					goto handle_Key

				case ffj_t_Label_Value:
					goto handle_Value

				case ffj_t_Labelno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Key:

	/* handler: uj.Key type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Key = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Value = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Value = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Labels) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Labels) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"labels":`)
	if mj.Labels != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Labels {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Labelsbase = iota
	ffj_t_Labelsno_such_key

	ffj_t_Labels_Labels
)

var ffj_key_Labels_Labels = []byte("labels")

func (uj *Labels) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Labels) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Labelsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Labelsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Labels_Labels, kn) {
						currentKey = ffj_t_Labels_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Labels_Labels, kn) {
					currentKey = ffj_t_Labels_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Labelsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Labels_Labels:
					goto handle_Labels

				case ffj_t_Labelsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Labels:

	/* handler: uj.Labels type=[]mesos.Label kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Labels = nil
		} else {

			uj.Labels = make([]Label, 0)

			wantVal := true

			for {

				var v Label

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Label kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Labels = append(uj.Labels, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MachineID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MachineID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Ip != nil {
		if true {
			buf.WriteString(`"ip":`)
			fflib.WriteJsonString(buf, string(*mj.Ip))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MachineIDbase = iota
	ffj_t_MachineIDno_such_key

	ffj_t_MachineID_Hostname

	ffj_t_MachineID_Ip
)

var ffj_key_MachineID_Hostname = []byte("hostname")

var ffj_key_MachineID_Ip = []byte("ip")

func (uj *MachineID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MachineID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MachineIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MachineIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_MachineID_Hostname, kn) {
						currentKey = ffj_t_MachineID_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MachineID_Ip, kn) {
						currentKey = ffj_t_MachineID_Ip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineID_Ip, kn) {
					currentKey = ffj_t_MachineID_Ip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MachineID_Hostname, kn) {
					currentKey = ffj_t_MachineID_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MachineIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MachineID_Hostname:
					goto handle_Hostname

				case ffj_t_MachineID_Ip:
					goto handle_Ip

				case ffj_t_MachineIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip:

	/* handler: uj.Ip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Ip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Ip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MachineInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MachineInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		err = mj.Id.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Mode != nil {
		if true {
			buf.WriteString(`"mode":`)

			{

				obj, err = mj.Mode.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Unavailability != nil {
		if true {
			buf.WriteString(`"unavailability":`)

			{

				err = mj.Unavailability.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MachineInfobase = iota
	ffj_t_MachineInfono_such_key

	ffj_t_MachineInfo_Id

	ffj_t_MachineInfo_Mode

	ffj_t_MachineInfo_Unavailability
)

var ffj_key_MachineInfo_Id = []byte("id")

var ffj_key_MachineInfo_Mode = []byte("mode")

var ffj_key_MachineInfo_Unavailability = []byte("unavailability")

func (uj *MachineInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MachineInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MachineInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MachineInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_MachineInfo_Id, kn) {
						currentKey = ffj_t_MachineInfo_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MachineInfo_Mode, kn) {
						currentKey = ffj_t_MachineInfo_Mode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_MachineInfo_Unavailability, kn) {
						currentKey = ffj_t_MachineInfo_Unavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineInfo_Unavailability, kn) {
					currentKey = ffj_t_MachineInfo_Unavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineInfo_Mode, kn) {
					currentKey = ffj_t_MachineInfo_Mode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MachineInfo_Id, kn) {
					currentKey = ffj_t_MachineInfo_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MachineInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MachineInfo_Id:
					goto handle_Id

				case ffj_t_MachineInfo_Mode:
					goto handle_Mode

				case ffj_t_MachineInfo_Unavailability:
					goto handle_Unavailability

				case ffj_t_MachineInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: uj.Id type=mesos.MachineID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Id.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mode:

	/* handler: uj.Mode type=mesos.MachineInfo_Mode kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mode = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Mode == nil {
			uj.Mode = new(MachineInfo_Mode)
		}

		err = uj.Mode.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailability:

	/* handler: uj.Unavailability type=mesos.Unavailability kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Unavailability = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Unavailability == nil {
			uj.Unavailability = new(Unavailability)
		}

		err = uj.Unavailability.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MasterInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MasterInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(mj.Id))
	buf.WriteString(`,"ip":`)
	fflib.FormatBits2(buf, uint64(mj.Ip), 10, false)
	buf.WriteByte(',')
	if mj.Port != nil {
		if true {
			buf.WriteString(`"port":`)
			fflib.FormatBits2(buf, uint64(*mj.Port), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Pid != nil {
		if true {
			buf.WriteString(`"pid":`)
			fflib.WriteJsonString(buf, string(*mj.Pid))
			buf.WriteByte(',')
		}
	}
	if mj.Hostname != nil {
		if true {
			buf.WriteString(`"hostname":`)
			fflib.WriteJsonString(buf, string(*mj.Hostname))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.WriteJsonString(buf, string(*mj.Version))
			buf.WriteByte(',')
		}
	}
	if mj.Address != nil {
		if true {
			buf.WriteString(`"address":`)

			{

				err = mj.Address.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MasterInfobase = iota
	ffj_t_MasterInfono_such_key

	ffj_t_MasterInfo_Id

	ffj_t_MasterInfo_Ip

	ffj_t_MasterInfo_Port

	ffj_t_MasterInfo_Pid

	ffj_t_MasterInfo_Hostname

	ffj_t_MasterInfo_Version

	ffj_t_MasterInfo_Address
)

var ffj_key_MasterInfo_Id = []byte("id")

var ffj_key_MasterInfo_Ip = []byte("ip")

var ffj_key_MasterInfo_Port = []byte("port")

var ffj_key_MasterInfo_Pid = []byte("pid")

var ffj_key_MasterInfo_Hostname = []byte("hostname")

var ffj_key_MasterInfo_Version = []byte("version")

var ffj_key_MasterInfo_Address = []byte("address")

func (uj *MasterInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MasterInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MasterInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MasterInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_MasterInfo_Address, kn) {
						currentKey = ffj_t_MasterInfo_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_MasterInfo_Hostname, kn) {
						currentKey = ffj_t_MasterInfo_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MasterInfo_Id, kn) {
						currentKey = ffj_t_MasterInfo_Id
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MasterInfo_Ip, kn) {
						currentKey = ffj_t_MasterInfo_Ip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_MasterInfo_Port, kn) {
						currentKey = ffj_t_MasterInfo_Port
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MasterInfo_Pid, kn) {
						currentKey = ffj_t_MasterInfo_Pid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_MasterInfo_Version, kn) {
						currentKey = ffj_t_MasterInfo_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MasterInfo_Address, kn) {
					currentKey = ffj_t_MasterInfo_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MasterInfo_Version, kn) {
					currentKey = ffj_t_MasterInfo_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MasterInfo_Hostname, kn) {
					currentKey = ffj_t_MasterInfo_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_Pid, kn) {
					currentKey = ffj_t_MasterInfo_Pid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_Port, kn) {
					currentKey = ffj_t_MasterInfo_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_Ip, kn) {
					currentKey = ffj_t_MasterInfo_Ip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MasterInfo_Id, kn) {
					currentKey = ffj_t_MasterInfo_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MasterInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MasterInfo_Id:
					goto handle_Id

				case ffj_t_MasterInfo_Ip:
					goto handle_Ip

				case ffj_t_MasterInfo_Port:
					goto handle_Port

				case ffj_t_MasterInfo_Pid:
					goto handle_Pid

				case ffj_t_MasterInfo_Hostname:
					goto handle_Hostname

				case ffj_t_MasterInfo_Version:
					goto handle_Version

				case ffj_t_MasterInfo_Address:
					goto handle_Address

				case ffj_t_MasterInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: uj.Id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ip:

	/* handler: uj.Ip type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Ip = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Port = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Port = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pid:

	/* handler: uj.Pid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Pid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Pid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Hostname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Hostname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Version = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=mesos.Address kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Address = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Address == nil {
			uj.Address = new(Address)
		}

		err = uj.Address.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)

	{

		err = mj.Id.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"framework_id":`)

	{

		err = mj.FrameworkId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"agent_id":`)

	{

		err = mj.AgentId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"hostname":`)
	fflib.WriteJsonString(buf, string(mj.Hostname))
	buf.WriteByte(',')
	if mj.Url != nil {
		if true {
			buf.WriteString(`"url":`)

			{

				err = mj.Url.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Attributes) != 0 {
		buf.WriteString(`"attributes":`)
		if mj.Attributes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Attributes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.ExecutorIds) != 0 {
		buf.WriteString(`"executor_ids":`)
		if mj.ExecutorIds != nil {
			buf.WriteString(`[`)
			for i, v := range mj.ExecutorIds {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Unavailability != nil {
		if true {
			buf.WriteString(`"unavailability":`)

			{

				err = mj.Unavailability.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offerbase = iota
	ffj_t_Offerno_such_key

	ffj_t_Offer_Id

	ffj_t_Offer_FrameworkId

	ffj_t_Offer_AgentId

	ffj_t_Offer_Hostname

	ffj_t_Offer_Url

	ffj_t_Offer_Resources

	ffj_t_Offer_Attributes

	ffj_t_Offer_ExecutorIds

	ffj_t_Offer_Unavailability
)

var ffj_key_Offer_Id = []byte("id")

var ffj_key_Offer_FrameworkId = []byte("framework_id")

var ffj_key_Offer_AgentId = []byte("agent_id")

var ffj_key_Offer_Hostname = []byte("hostname")

var ffj_key_Offer_Url = []byte("url")

var ffj_key_Offer_Resources = []byte("resources")

var ffj_key_Offer_Attributes = []byte("attributes")

var ffj_key_Offer_ExecutorIds = []byte("executor_ids")

var ffj_key_Offer_Unavailability = []byte("unavailability")

func (uj *Offer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Offer_AgentId, kn) {
						currentKey = ffj_t_Offer_AgentId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Offer_Attributes, kn) {
						currentKey = ffj_t_Offer_Attributes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Offer_ExecutorIds, kn) {
						currentKey = ffj_t_Offer_ExecutorIds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Offer_FrameworkId, kn) {
						currentKey = ffj_t_Offer_FrameworkId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Offer_Hostname, kn) {
						currentKey = ffj_t_Offer_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Offer_Id, kn) {
						currentKey = ffj_t_Offer_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Offer_Resources, kn) {
						currentKey = ffj_t_Offer_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Offer_Url, kn) {
						currentKey = ffj_t_Offer_Url
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Offer_Unavailability, kn) {
						currentKey = ffj_t_Offer_Unavailability
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Unavailability, kn) {
					currentKey = ffj_t_Offer_Unavailability
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_ExecutorIds, kn) {
					currentKey = ffj_t_Offer_ExecutorIds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Attributes, kn) {
					currentKey = ffj_t_Offer_Attributes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Resources, kn) {
					currentKey = ffj_t_Offer_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Url, kn) {
					currentKey = ffj_t_Offer_Url
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Hostname, kn) {
					currentKey = ffj_t_Offer_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Offer_AgentId, kn) {
					currentKey = ffj_t_Offer_AgentId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_FrameworkId, kn) {
					currentKey = ffj_t_Offer_FrameworkId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Id, kn) {
					currentKey = ffj_t_Offer_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Id:
					goto handle_Id

				case ffj_t_Offer_FrameworkId:
					goto handle_FrameworkId

				case ffj_t_Offer_AgentId:
					goto handle_AgentId

				case ffj_t_Offer_Hostname:
					goto handle_Hostname

				case ffj_t_Offer_Url:
					goto handle_Url

				case ffj_t_Offer_Resources:
					goto handle_Resources

				case ffj_t_Offer_Attributes:
					goto handle_Attributes

				case ffj_t_Offer_ExecutorIds:
					goto handle_ExecutorIds

				case ffj_t_Offer_Unavailability:
					goto handle_Unavailability

				case ffj_t_Offerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: uj.Id type=mesos.OfferID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Id.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FrameworkId:

	/* handler: uj.FrameworkId type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.FrameworkId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentId:

	/* handler: uj.AgentId type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.AgentId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Hostname = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Url:

	/* handler: uj.Url type=mesos.URL kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Url = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Url == nil {
			uj.Url = new(URL)
		}

		err = uj.Url.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attributes:

	/* handler: uj.Attributes type=[]*mesos.Attribute kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attributes = nil
		} else {

			uj.Attributes = make([]*Attribute, 0)

			wantVal := true

			for {

				var v *Attribute

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Attribute kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Attribute)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attributes = append(uj.Attributes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutorIds:

	/* handler: uj.ExecutorIds type=[]*mesos.ExecutorID kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ExecutorIds = nil
		} else {

			uj.ExecutorIds = make([]*ExecutorID, 0)

			wantVal := true

			for {

				var v *ExecutorID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.ExecutorID kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(ExecutorID)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ExecutorIds = append(uj.ExecutorIds, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unavailability:

	/* handler: uj.Unavailability type=mesos.Unavailability kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Unavailability = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Unavailability == nil {
			uj.Unavailability = new(Unavailability)
		}

		err = uj.Unavailability.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *OfferID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *OfferID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_OfferIDbase = iota
	ffj_t_OfferIDno_such_key

	ffj_t_OfferID_Value
)

var ffj_key_OfferID_Value = []byte("value")

func (uj *OfferID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *OfferID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_OfferIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_OfferIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_OfferID_Value, kn) {
						currentKey = ffj_t_OfferID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_OfferID_Value, kn) {
					currentKey = ffj_t_OfferID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_OfferIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_OfferID_Value:
					goto handle_Value

				case ffj_t_OfferIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Launch != nil {
		if true {
			buf.WriteString(`"launch":`)

			{

				err = mj.Launch.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Reserve != nil {
		if true {
			buf.WriteString(`"reserve":`)

			{

				err = mj.Reserve.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Unreserve != nil {
		if true {
			buf.WriteString(`"unreserve":`)

			{

				err = mj.Unreserve.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Create != nil {
		if true {
			buf.WriteString(`"create":`)

			{

				err = mj.Create.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Destroy != nil {
		if true {
			buf.WriteString(`"destroy":`)

			{

				err = mj.Destroy.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operationbase = iota
	ffj_t_Offer_Operationno_such_key

	ffj_t_Offer_Operation_Type

	ffj_t_Offer_Operation_Launch

	ffj_t_Offer_Operation_Reserve

	ffj_t_Offer_Operation_Unreserve

	ffj_t_Offer_Operation_Create

	ffj_t_Offer_Operation_Destroy
)

var ffj_key_Offer_Operation_Type = []byte("type")

var ffj_key_Offer_Operation_Launch = []byte("launch")

var ffj_key_Offer_Operation_Reserve = []byte("reserve")

var ffj_key_Offer_Operation_Unreserve = []byte("unreserve")

var ffj_key_Offer_Operation_Create = []byte("create")

var ffj_key_Offer_Operation_Destroy = []byte("destroy")

func (uj *Offer_Operation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Offer_Operation_Create, kn) {
						currentKey = ffj_t_Offer_Operation_Create
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Offer_Operation_Destroy, kn) {
						currentKey = ffj_t_Offer_Operation_Destroy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Offer_Operation_Launch, kn) {
						currentKey = ffj_t_Offer_Operation_Launch
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Offer_Operation_Reserve, kn) {
						currentKey = ffj_t_Offer_Operation_Reserve
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Offer_Operation_Type, kn) {
						currentKey = ffj_t_Offer_Operation_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Offer_Operation_Unreserve, kn) {
						currentKey = ffj_t_Offer_Operation_Unreserve
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Destroy, kn) {
					currentKey = ffj_t_Offer_Operation_Destroy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Operation_Create, kn) {
					currentKey = ffj_t_Offer_Operation_Create
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Unreserve, kn) {
					currentKey = ffj_t_Offer_Operation_Unreserve
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Reserve, kn) {
					currentKey = ffj_t_Offer_Operation_Reserve
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Operation_Launch, kn) {
					currentKey = ffj_t_Offer_Operation_Launch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Offer_Operation_Type, kn) {
					currentKey = ffj_t_Offer_Operation_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Type:
					goto handle_Type

				case ffj_t_Offer_Operation_Launch:
					goto handle_Launch

				case ffj_t_Offer_Operation_Reserve:
					goto handle_Reserve

				case ffj_t_Offer_Operation_Unreserve:
					goto handle_Unreserve

				case ffj_t_Offer_Operation_Create:
					goto handle_Create

				case ffj_t_Offer_Operation_Destroy:
					goto handle_Destroy

				case ffj_t_Offer_Operationno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Offer_Operation_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Offer_Operation_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Launch:

	/* handler: uj.Launch type=mesos.Offer_Operation_Launch kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Launch = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Launch == nil {
			uj.Launch = new(Offer_Operation_Launch)
		}

		err = uj.Launch.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reserve:

	/* handler: uj.Reserve type=mesos.Offer_Operation_Reserve kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reserve = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Reserve == nil {
			uj.Reserve = new(Offer_Operation_Reserve)
		}

		err = uj.Reserve.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unreserve:

	/* handler: uj.Unreserve type=mesos.Offer_Operation_Unreserve kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Unreserve = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Unreserve == nil {
			uj.Unreserve = new(Offer_Operation_Unreserve)
		}

		err = uj.Unreserve.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Create:

	/* handler: uj.Create type=mesos.Offer_Operation_Create kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Create = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Create == nil {
			uj.Create = new(Offer_Operation_Create)
		}

		err = uj.Create.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Destroy:

	/* handler: uj.Destroy type=mesos.Offer_Operation_Destroy kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Destroy = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Destroy == nil {
			uj.Destroy = new(Offer_Operation_Destroy)
		}

		err = uj.Destroy.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Create) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Create) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Volumes) != 0 {
		buf.WriteString(`"volumes":`)
		if mj.Volumes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Volumes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Createbase = iota
	ffj_t_Offer_Operation_Createno_such_key

	ffj_t_Offer_Operation_Create_Volumes
)

var ffj_key_Offer_Operation_Create_Volumes = []byte("volumes")

func (uj *Offer_Operation_Create) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Create) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Createbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Createno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Offer_Operation_Create_Volumes, kn) {
						currentKey = ffj_t_Offer_Operation_Create_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Create_Volumes, kn) {
					currentKey = ffj_t_Offer_Operation_Create_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Createno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Create_Volumes:
					goto handle_Volumes

				case ffj_t_Offer_Operation_Createno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Volumes:

	/* handler: uj.Volumes type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Destroy) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Destroy) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Volumes) != 0 {
		buf.WriteString(`"volumes":`)
		if mj.Volumes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Volumes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Destroybase = iota
	ffj_t_Offer_Operation_Destroyno_such_key

	ffj_t_Offer_Operation_Destroy_Volumes
)

var ffj_key_Offer_Operation_Destroy_Volumes = []byte("volumes")

func (uj *Offer_Operation_Destroy) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Destroy) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Destroybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Destroyno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Offer_Operation_Destroy_Volumes, kn) {
						currentKey = ffj_t_Offer_Operation_Destroy_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Destroy_Volumes, kn) {
					currentKey = ffj_t_Offer_Operation_Destroy_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Destroyno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Destroy_Volumes:
					goto handle_Volumes

				case ffj_t_Offer_Operation_Destroyno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Volumes:

	/* handler: uj.Volumes type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Launch) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Launch) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.TaskInfos) != 0 {
		buf.WriteString(`"task_infos":`)
		if mj.TaskInfos != nil {
			buf.WriteString(`[`)
			for i, v := range mj.TaskInfos {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Launchbase = iota
	ffj_t_Offer_Operation_Launchno_such_key

	ffj_t_Offer_Operation_Launch_TaskInfos
)

var ffj_key_Offer_Operation_Launch_TaskInfos = []byte("task_infos")

func (uj *Offer_Operation_Launch) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Launch) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Launchbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Launchno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffj_key_Offer_Operation_Launch_TaskInfos, kn) {
						currentKey = ffj_t_Offer_Operation_Launch_TaskInfos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Launch_TaskInfos, kn) {
					currentKey = ffj_t_Offer_Operation_Launch_TaskInfos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Launchno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Launch_TaskInfos:
					goto handle_TaskInfos

				case ffj_t_Offer_Operation_Launchno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TaskInfos:

	/* handler: uj.TaskInfos type=[]*mesos.TaskInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.TaskInfos = nil
		} else {

			uj.TaskInfos = make([]*TaskInfo, 0)

			wantVal := true

			for {

				var v *TaskInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.TaskInfo kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(TaskInfo)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.TaskInfos = append(uj.TaskInfos, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Reserve) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Reserve) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Reservebase = iota
	ffj_t_Offer_Operation_Reserveno_such_key

	ffj_t_Offer_Operation_Reserve_Resources
)

var ffj_key_Offer_Operation_Reserve_Resources = []byte("resources")

func (uj *Offer_Operation_Reserve) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Reserve) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Reservebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Reserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Offer_Operation_Reserve_Resources, kn) {
						currentKey = ffj_t_Offer_Operation_Reserve_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Reserve_Resources, kn) {
					currentKey = ffj_t_Offer_Operation_Reserve_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Reserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Reserve_Resources:
					goto handle_Resources

				case ffj_t_Offer_Operation_Reserveno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Offer_Operation_Unreserve) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Offer_Operation_Unreserve) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Offer_Operation_Unreservebase = iota
	ffj_t_Offer_Operation_Unreserveno_such_key

	ffj_t_Offer_Operation_Unreserve_Resources
)

var ffj_key_Offer_Operation_Unreserve_Resources = []byte("resources")

func (uj *Offer_Operation_Unreserve) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Offer_Operation_Unreserve) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Offer_Operation_Unreservebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Offer_Operation_Unreserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Offer_Operation_Unreserve_Resources, kn) {
						currentKey = ffj_t_Offer_Operation_Unreserve_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Offer_Operation_Unreserve_Resources, kn) {
					currentKey = ffj_t_Offer_Operation_Unreserve_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Offer_Operation_Unreserveno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Offer_Operation_Unreserve_Resources:
					goto handle_Resources

				case ffj_t_Offer_Operation_Unreserveno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Parameter) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Parameter) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"key":`)
	fflib.WriteJsonString(buf, string(mj.Key))
	buf.WriteString(`,"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Parameterbase = iota
	ffj_t_Parameterno_such_key

	ffj_t_Parameter_Key

	ffj_t_Parameter_Value
)

var ffj_key_Parameter_Key = []byte("key")

var ffj_key_Parameter_Value = []byte("value")

func (uj *Parameter) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Parameter) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Parameterbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Parameterno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffj_key_Parameter_Key, kn) {
						currentKey = ffj_t_Parameter_Key
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Parameter_Value, kn) {
						currentKey = ffj_t_Parameter_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Parameter_Value, kn) {
					currentKey = ffj_t_Parameter_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Parameter_Key, kn) {
					currentKey = ffj_t_Parameter_Key
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Parameterno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Parameter_Key:
					goto handle_Key

				case ffj_t_Parameter_Value:
					goto handle_Value

				case ffj_t_Parameterno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Key:

	/* handler: uj.Key type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Key = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Parameters) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Parameters) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Parameter) != 0 {
		buf.WriteString(`"parameter":`)
		if mj.Parameter != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Parameter {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Parametersbase = iota
	ffj_t_Parametersno_such_key

	ffj_t_Parameters_Parameter
)

var ffj_key_Parameters_Parameter = []byte("parameter")

func (uj *Parameters) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Parameters) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Parametersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Parametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Parameters_Parameter, kn) {
						currentKey = ffj_t_Parameters_Parameter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Parameters_Parameter, kn) {
					currentKey = ffj_t_Parameters_Parameter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Parametersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Parameters_Parameter:
					goto handle_Parameter

				case ffj_t_Parametersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Parameter:

	/* handler: uj.Parameter type=[]*mesos.Parameter kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Parameter = nil
		} else {

			uj.Parameter = make([]*Parameter, 0)

			wantVal := true

			for {

				var v *Parameter

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Parameter kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Parameter)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Parameter = append(uj.Parameter, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PerfStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PerfStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "timestamp":`)
	fflib.AppendFloat(buf, float64(mj.Timestamp), 'g', -1, 64)
	buf.WriteString(`,"duration":`)
	fflib.AppendFloat(buf, float64(mj.Duration), 'g', -1, 64)
	buf.WriteByte(',')
	if mj.Cycles != nil {
		if true {
			buf.WriteString(`"cycles":`)
			fflib.FormatBits2(buf, uint64(*mj.Cycles), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.StalledCyclesFrontend != nil {
		if true {
			buf.WriteString(`"stalled_cycles_frontend":`)
			fflib.FormatBits2(buf, uint64(*mj.StalledCyclesFrontend), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.StalledCyclesBackend != nil {
		if true {
			buf.WriteString(`"stalled_cycles_backend":`)
			fflib.FormatBits2(buf, uint64(*mj.StalledCyclesBackend), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Instructions != nil {
		if true {
			buf.WriteString(`"instructions":`)
			fflib.FormatBits2(buf, uint64(*mj.Instructions), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CacheReferences != nil {
		if true {
			buf.WriteString(`"cache_references":`)
			fflib.FormatBits2(buf, uint64(*mj.CacheReferences), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CacheMisses != nil {
		if true {
			buf.WriteString(`"cache_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.CacheMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Branches != nil {
		if true {
			buf.WriteString(`"branches":`)
			fflib.FormatBits2(buf, uint64(*mj.Branches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BranchMisses != nil {
		if true {
			buf.WriteString(`"branch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.BranchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BusCycles != nil {
		if true {
			buf.WriteString(`"bus_cycles":`)
			fflib.FormatBits2(buf, uint64(*mj.BusCycles), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.RefCycles != nil {
		if true {
			buf.WriteString(`"ref_cycles":`)
			fflib.FormatBits2(buf, uint64(*mj.RefCycles), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpuClock != nil {
		if true {
			buf.WriteString(`"cpu_clock":`)
			fflib.AppendFloat(buf, float64(*mj.CpuClock), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.TaskClock != nil {
		if true {
			buf.WriteString(`"task_clock":`)
			fflib.AppendFloat(buf, float64(*mj.TaskClock), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.PageFaults != nil {
		if true {
			buf.WriteString(`"page_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.PageFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MinorFaults != nil {
		if true {
			buf.WriteString(`"minor_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.MinorFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MajorFaults != nil {
		if true {
			buf.WriteString(`"major_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.MajorFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.ContextSwitches != nil {
		if true {
			buf.WriteString(`"context_switches":`)
			fflib.FormatBits2(buf, uint64(*mj.ContextSwitches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpuMigrations != nil {
		if true {
			buf.WriteString(`"cpu_migrations":`)
			fflib.FormatBits2(buf, uint64(*mj.CpuMigrations), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.AlignmentFaults != nil {
		if true {
			buf.WriteString(`"alignment_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.AlignmentFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.EmulationFaults != nil {
		if true {
			buf.WriteString(`"emulation_faults":`)
			fflib.FormatBits2(buf, uint64(*mj.EmulationFaults), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheLoads != nil {
		if true {
			buf.WriteString(`"l1_dcache_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheLoadMisses != nil {
		if true {
			buf.WriteString(`"l1_dcache_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheStores != nil {
		if true {
			buf.WriteString(`"l1_dcache_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcacheStoreMisses != nil {
		if true {
			buf.WriteString(`"l1_dcache_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcacheStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcachePrefetches != nil {
		if true {
			buf.WriteString(`"l1_dcache_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcachePrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1DcachePrefetchMisses != nil {
		if true {
			buf.WriteString(`"l1_dcache_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1DcachePrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcacheLoads != nil {
		if true {
			buf.WriteString(`"l1_icache_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcacheLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcacheLoadMisses != nil {
		if true {
			buf.WriteString(`"l1_icache_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcacheLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcachePrefetches != nil {
		if true {
			buf.WriteString(`"l1_icache_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcachePrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.L1IcachePrefetchMisses != nil {
		if true {
			buf.WriteString(`"l1_icache_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.L1IcachePrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcLoads != nil {
		if true {
			buf.WriteString(`"llc_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcLoadMisses != nil {
		if true {
			buf.WriteString(`"llc_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcStores != nil {
		if true {
			buf.WriteString(`"llc_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcStoreMisses != nil {
		if true {
			buf.WriteString(`"llc_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcPrefetches != nil {
		if true {
			buf.WriteString(`"llc_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcPrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.LlcPrefetchMisses != nil {
		if true {
			buf.WriteString(`"llc_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.LlcPrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbLoads != nil {
		if true {
			buf.WriteString(`"dtlb_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbLoadMisses != nil {
		if true {
			buf.WriteString(`"dtlb_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbStores != nil {
		if true {
			buf.WriteString(`"dtlb_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbStoreMisses != nil {
		if true {
			buf.WriteString(`"dtlb_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbPrefetches != nil {
		if true {
			buf.WriteString(`"dtlb_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbPrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DtlbPrefetchMisses != nil {
		if true {
			buf.WriteString(`"dtlb_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.DtlbPrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.ItlbLoads != nil {
		if true {
			buf.WriteString(`"itlb_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.ItlbLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.ItlbLoadMisses != nil {
		if true {
			buf.WriteString(`"itlb_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.ItlbLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BranchLoads != nil {
		if true {
			buf.WriteString(`"branch_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.BranchLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.BranchLoadMisses != nil {
		if true {
			buf.WriteString(`"branch_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.BranchLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeLoads != nil {
		if true {
			buf.WriteString(`"node_loads":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeLoads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeLoadMisses != nil {
		if true {
			buf.WriteString(`"node_load_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeLoadMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeStores != nil {
		if true {
			buf.WriteString(`"node_stores":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeStores), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodeStoreMisses != nil {
		if true {
			buf.WriteString(`"node_store_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.NodeStoreMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodePrefetches != nil {
		if true {
			buf.WriteString(`"node_prefetches":`)
			fflib.FormatBits2(buf, uint64(*mj.NodePrefetches), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NodePrefetchMisses != nil {
		if true {
			buf.WriteString(`"node_prefetch_misses":`)
			fflib.FormatBits2(buf, uint64(*mj.NodePrefetchMisses), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PerfStatisticsbase = iota
	ffj_t_PerfStatisticsno_such_key

	ffj_t_PerfStatistics_Timestamp

	ffj_t_PerfStatistics_Duration

	ffj_t_PerfStatistics_Cycles

	ffj_t_PerfStatistics_StalledCyclesFrontend

	ffj_t_PerfStatistics_StalledCyclesBackend

	ffj_t_PerfStatistics_Instructions

	ffj_t_PerfStatistics_CacheReferences

	ffj_t_PerfStatistics_CacheMisses

	ffj_t_PerfStatistics_Branches

	ffj_t_PerfStatistics_BranchMisses

	ffj_t_PerfStatistics_BusCycles

	ffj_t_PerfStatistics_RefCycles

	ffj_t_PerfStatistics_CpuClock

	ffj_t_PerfStatistics_TaskClock

	ffj_t_PerfStatistics_PageFaults

	ffj_t_PerfStatistics_MinorFaults

	ffj_t_PerfStatistics_MajorFaults

	ffj_t_PerfStatistics_ContextSwitches

	ffj_t_PerfStatistics_CpuMigrations

	ffj_t_PerfStatistics_AlignmentFaults

	ffj_t_PerfStatistics_EmulationFaults

	ffj_t_PerfStatistics_L1DcacheLoads

	ffj_t_PerfStatistics_L1DcacheLoadMisses

	ffj_t_PerfStatistics_L1DcacheStores

	ffj_t_PerfStatistics_L1DcacheStoreMisses

	ffj_t_PerfStatistics_L1DcachePrefetches

	ffj_t_PerfStatistics_L1DcachePrefetchMisses

	ffj_t_PerfStatistics_L1IcacheLoads

	ffj_t_PerfStatistics_L1IcacheLoadMisses

	ffj_t_PerfStatistics_L1IcachePrefetches

	ffj_t_PerfStatistics_L1IcachePrefetchMisses

	ffj_t_PerfStatistics_LlcLoads

	ffj_t_PerfStatistics_LlcLoadMisses

	ffj_t_PerfStatistics_LlcStores

	ffj_t_PerfStatistics_LlcStoreMisses

	ffj_t_PerfStatistics_LlcPrefetches

	ffj_t_PerfStatistics_LlcPrefetchMisses

	ffj_t_PerfStatistics_DtlbLoads

	ffj_t_PerfStatistics_DtlbLoadMisses

	ffj_t_PerfStatistics_DtlbStores

	ffj_t_PerfStatistics_DtlbStoreMisses

	ffj_t_PerfStatistics_DtlbPrefetches

	ffj_t_PerfStatistics_DtlbPrefetchMisses

	ffj_t_PerfStatistics_ItlbLoads

	ffj_t_PerfStatistics_ItlbLoadMisses

	ffj_t_PerfStatistics_BranchLoads

	ffj_t_PerfStatistics_BranchLoadMisses

	ffj_t_PerfStatistics_NodeLoads

	ffj_t_PerfStatistics_NodeLoadMisses

	ffj_t_PerfStatistics_NodeStores

	ffj_t_PerfStatistics_NodeStoreMisses

	ffj_t_PerfStatistics_NodePrefetches

	ffj_t_PerfStatistics_NodePrefetchMisses
)

var ffj_key_PerfStatistics_Timestamp = []byte("timestamp")

var ffj_key_PerfStatistics_Duration = []byte("duration")

var ffj_key_PerfStatistics_Cycles = []byte("cycles")

var ffj_key_PerfStatistics_StalledCyclesFrontend = []byte("stalled_cycles_frontend")

var ffj_key_PerfStatistics_StalledCyclesBackend = []byte("stalled_cycles_backend")

var ffj_key_PerfStatistics_Instructions = []byte("instructions")

var ffj_key_PerfStatistics_CacheReferences = []byte("cache_references")

var ffj_key_PerfStatistics_CacheMisses = []byte("cache_misses")

var ffj_key_PerfStatistics_Branches = []byte("branches")

var ffj_key_PerfStatistics_BranchMisses = []byte("branch_misses")

var ffj_key_PerfStatistics_BusCycles = []byte("bus_cycles")

var ffj_key_PerfStatistics_RefCycles = []byte("ref_cycles")

var ffj_key_PerfStatistics_CpuClock = []byte("cpu_clock")

var ffj_key_PerfStatistics_TaskClock = []byte("task_clock")

var ffj_key_PerfStatistics_PageFaults = []byte("page_faults")

var ffj_key_PerfStatistics_MinorFaults = []byte("minor_faults")

var ffj_key_PerfStatistics_MajorFaults = []byte("major_faults")

var ffj_key_PerfStatistics_ContextSwitches = []byte("context_switches")

var ffj_key_PerfStatistics_CpuMigrations = []byte("cpu_migrations")

var ffj_key_PerfStatistics_AlignmentFaults = []byte("alignment_faults")

var ffj_key_PerfStatistics_EmulationFaults = []byte("emulation_faults")

var ffj_key_PerfStatistics_L1DcacheLoads = []byte("l1_dcache_loads")

var ffj_key_PerfStatistics_L1DcacheLoadMisses = []byte("l1_dcache_load_misses")

var ffj_key_PerfStatistics_L1DcacheStores = []byte("l1_dcache_stores")

var ffj_key_PerfStatistics_L1DcacheStoreMisses = []byte("l1_dcache_store_misses")

var ffj_key_PerfStatistics_L1DcachePrefetches = []byte("l1_dcache_prefetches")

var ffj_key_PerfStatistics_L1DcachePrefetchMisses = []byte("l1_dcache_prefetch_misses")

var ffj_key_PerfStatistics_L1IcacheLoads = []byte("l1_icache_loads")

var ffj_key_PerfStatistics_L1IcacheLoadMisses = []byte("l1_icache_load_misses")

var ffj_key_PerfStatistics_L1IcachePrefetches = []byte("l1_icache_prefetches")

var ffj_key_PerfStatistics_L1IcachePrefetchMisses = []byte("l1_icache_prefetch_misses")

var ffj_key_PerfStatistics_LlcLoads = []byte("llc_loads")

var ffj_key_PerfStatistics_LlcLoadMisses = []byte("llc_load_misses")

var ffj_key_PerfStatistics_LlcStores = []byte("llc_stores")

var ffj_key_PerfStatistics_LlcStoreMisses = []byte("llc_store_misses")

var ffj_key_PerfStatistics_LlcPrefetches = []byte("llc_prefetches")

var ffj_key_PerfStatistics_LlcPrefetchMisses = []byte("llc_prefetch_misses")

var ffj_key_PerfStatistics_DtlbLoads = []byte("dtlb_loads")

var ffj_key_PerfStatistics_DtlbLoadMisses = []byte("dtlb_load_misses")

var ffj_key_PerfStatistics_DtlbStores = []byte("dtlb_stores")

var ffj_key_PerfStatistics_DtlbStoreMisses = []byte("dtlb_store_misses")

var ffj_key_PerfStatistics_DtlbPrefetches = []byte("dtlb_prefetches")

var ffj_key_PerfStatistics_DtlbPrefetchMisses = []byte("dtlb_prefetch_misses")

var ffj_key_PerfStatistics_ItlbLoads = []byte("itlb_loads")

var ffj_key_PerfStatistics_ItlbLoadMisses = []byte("itlb_load_misses")

var ffj_key_PerfStatistics_BranchLoads = []byte("branch_loads")

var ffj_key_PerfStatistics_BranchLoadMisses = []byte("branch_load_misses")

var ffj_key_PerfStatistics_NodeLoads = []byte("node_loads")

var ffj_key_PerfStatistics_NodeLoadMisses = []byte("node_load_misses")

var ffj_key_PerfStatistics_NodeStores = []byte("node_stores")

var ffj_key_PerfStatistics_NodeStoreMisses = []byte("node_store_misses")

var ffj_key_PerfStatistics_NodePrefetches = []byte("node_prefetches")

var ffj_key_PerfStatistics_NodePrefetchMisses = []byte("node_prefetch_misses")

func (uj *PerfStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PerfStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PerfStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PerfStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PerfStatistics_AlignmentFaults, kn) {
						currentKey = ffj_t_PerfStatistics_AlignmentFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_PerfStatistics_Branches, kn) {
						currentKey = ffj_t_PerfStatistics_Branches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BranchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_BranchMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BusCycles, kn) {
						currentKey = ffj_t_PerfStatistics_BusCycles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BranchLoads, kn) {
						currentKey = ffj_t_PerfStatistics_BranchLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_BranchLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_BranchLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PerfStatistics_Cycles, kn) {
						currentKey = ffj_t_PerfStatistics_Cycles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CacheReferences, kn) {
						currentKey = ffj_t_PerfStatistics_CacheReferences
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CacheMisses, kn) {
						currentKey = ffj_t_PerfStatistics_CacheMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CpuClock, kn) {
						currentKey = ffj_t_PerfStatistics_CpuClock
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_ContextSwitches, kn) {
						currentKey = ffj_t_PerfStatistics_ContextSwitches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_CpuMigrations, kn) {
						currentKey = ffj_t_PerfStatistics_CpuMigrations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_PerfStatistics_Duration, kn) {
						currentKey = ffj_t_PerfStatistics_Duration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbLoads, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbStores, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbPrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbPrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_DtlbPrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_DtlbPrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_PerfStatistics_EmulationFaults, kn) {
						currentKey = ffj_t_PerfStatistics_EmulationFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PerfStatistics_Instructions, kn) {
						currentKey = ffj_t_PerfStatistics_Instructions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_ItlbLoads, kn) {
						currentKey = ffj_t_PerfStatistics_ItlbLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_ItlbLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_ItlbLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_PerfStatistics_L1DcacheLoads, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcacheLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcacheStores, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcacheStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcacheStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcachePrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcachePrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1DcachePrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1DcachePrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcacheLoads, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcacheLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcacheLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcacheLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcachePrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcachePrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_L1IcachePrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_L1IcachePrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcLoads, kn) {
						currentKey = ffj_t_PerfStatistics_LlcLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_LlcLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcStores, kn) {
						currentKey = ffj_t_PerfStatistics_LlcStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_LlcStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcPrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_LlcPrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_LlcPrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_LlcPrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PerfStatistics_MinorFaults, kn) {
						currentKey = ffj_t_PerfStatistics_MinorFaults
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_MajorFaults, kn) {
						currentKey = ffj_t_PerfStatistics_MajorFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_PerfStatistics_NodeLoads, kn) {
						currentKey = ffj_t_PerfStatistics_NodeLoads
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodeLoadMisses, kn) {
						currentKey = ffj_t_PerfStatistics_NodeLoadMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodeStores, kn) {
						currentKey = ffj_t_PerfStatistics_NodeStores
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodeStoreMisses, kn) {
						currentKey = ffj_t_PerfStatistics_NodeStoreMisses
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodePrefetches, kn) {
						currentKey = ffj_t_PerfStatistics_NodePrefetches
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_NodePrefetchMisses, kn) {
						currentKey = ffj_t_PerfStatistics_NodePrefetchMisses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PerfStatistics_PageFaults, kn) {
						currentKey = ffj_t_PerfStatistics_PageFaults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PerfStatistics_RefCycles, kn) {
						currentKey = ffj_t_PerfStatistics_RefCycles
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PerfStatistics_StalledCyclesFrontend, kn) {
						currentKey = ffj_t_PerfStatistics_StalledCyclesFrontend
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_StalledCyclesBackend, kn) {
						currentKey = ffj_t_PerfStatistics_StalledCyclesBackend
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PerfStatistics_Timestamp, kn) {
						currentKey = ffj_t_PerfStatistics_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PerfStatistics_TaskClock, kn) {
						currentKey = ffj_t_PerfStatistics_TaskClock
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodePrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_NodePrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodePrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_NodePrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_NodeStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeStores, kn) {
					currentKey = ffj_t_PerfStatistics_NodeStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_NodeLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_NodeLoads, kn) {
					currentKey = ffj_t_PerfStatistics_NodeLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BranchLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_BranchLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BranchLoads, kn) {
					currentKey = ffj_t_PerfStatistics_BranchLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_ItlbLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_ItlbLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_ItlbLoads, kn) {
					currentKey = ffj_t_PerfStatistics_ItlbLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbPrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbPrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbPrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbPrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbStores, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_DtlbLoads, kn) {
					currentKey = ffj_t_PerfStatistics_DtlbLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcPrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_LlcPrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcPrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_LlcPrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_LlcStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcStores, kn) {
					currentKey = ffj_t_PerfStatistics_LlcStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_LlcLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_LlcLoads, kn) {
					currentKey = ffj_t_PerfStatistics_LlcLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcachePrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcachePrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcachePrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcachePrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcacheLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcacheLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1IcacheLoads, kn) {
					currentKey = ffj_t_PerfStatistics_L1IcacheLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcachePrefetchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcachePrefetchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcachePrefetches, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcachePrefetches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheStoreMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheStoreMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheStores, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheStores
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheLoadMisses, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheLoadMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_L1DcacheLoads, kn) {
					currentKey = ffj_t_PerfStatistics_L1DcacheLoads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_EmulationFaults, kn) {
					currentKey = ffj_t_PerfStatistics_EmulationFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_AlignmentFaults, kn) {
					currentKey = ffj_t_PerfStatistics_AlignmentFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CpuMigrations, kn) {
					currentKey = ffj_t_PerfStatistics_CpuMigrations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_ContextSwitches, kn) {
					currentKey = ffj_t_PerfStatistics_ContextSwitches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_MajorFaults, kn) {
					currentKey = ffj_t_PerfStatistics_MajorFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_MinorFaults, kn) {
					currentKey = ffj_t_PerfStatistics_MinorFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_PageFaults, kn) {
					currentKey = ffj_t_PerfStatistics_PageFaults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_TaskClock, kn) {
					currentKey = ffj_t_PerfStatistics_TaskClock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CpuClock, kn) {
					currentKey = ffj_t_PerfStatistics_CpuClock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_RefCycles, kn) {
					currentKey = ffj_t_PerfStatistics_RefCycles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BusCycles, kn) {
					currentKey = ffj_t_PerfStatistics_BusCycles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_BranchMisses, kn) {
					currentKey = ffj_t_PerfStatistics_BranchMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Branches, kn) {
					currentKey = ffj_t_PerfStatistics_Branches
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CacheMisses, kn) {
					currentKey = ffj_t_PerfStatistics_CacheMisses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_CacheReferences, kn) {
					currentKey = ffj_t_PerfStatistics_CacheReferences
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Instructions, kn) {
					currentKey = ffj_t_PerfStatistics_Instructions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_StalledCyclesBackend, kn) {
					currentKey = ffj_t_PerfStatistics_StalledCyclesBackend
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_StalledCyclesFrontend, kn) {
					currentKey = ffj_t_PerfStatistics_StalledCyclesFrontend
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Cycles, kn) {
					currentKey = ffj_t_PerfStatistics_Cycles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PerfStatistics_Duration, kn) {
					currentKey = ffj_t_PerfStatistics_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PerfStatistics_Timestamp, kn) {
					currentKey = ffj_t_PerfStatistics_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PerfStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PerfStatistics_Timestamp:
					goto handle_Timestamp

				case ffj_t_PerfStatistics_Duration:
					goto handle_Duration

				case ffj_t_PerfStatistics_Cycles:
					goto handle_Cycles

				case ffj_t_PerfStatistics_StalledCyclesFrontend:
					goto handle_StalledCyclesFrontend

				case ffj_t_PerfStatistics_StalledCyclesBackend:
					goto handle_StalledCyclesBackend

				case ffj_t_PerfStatistics_Instructions:
					goto handle_Instructions

				case ffj_t_PerfStatistics_CacheReferences:
					goto handle_CacheReferences

				case ffj_t_PerfStatistics_CacheMisses:
					goto handle_CacheMisses

				case ffj_t_PerfStatistics_Branches:
					goto handle_Branches

				case ffj_t_PerfStatistics_BranchMisses:
					goto handle_BranchMisses

				case ffj_t_PerfStatistics_BusCycles:
					goto handle_BusCycles

				case ffj_t_PerfStatistics_RefCycles:
					goto handle_RefCycles

				case ffj_t_PerfStatistics_CpuClock:
					goto handle_CpuClock

				case ffj_t_PerfStatistics_TaskClock:
					goto handle_TaskClock

				case ffj_t_PerfStatistics_PageFaults:
					goto handle_PageFaults

				case ffj_t_PerfStatistics_MinorFaults:
					goto handle_MinorFaults

				case ffj_t_PerfStatistics_MajorFaults:
					goto handle_MajorFaults

				case ffj_t_PerfStatistics_ContextSwitches:
					goto handle_ContextSwitches

				case ffj_t_PerfStatistics_CpuMigrations:
					goto handle_CpuMigrations

				case ffj_t_PerfStatistics_AlignmentFaults:
					goto handle_AlignmentFaults

				case ffj_t_PerfStatistics_EmulationFaults:
					goto handle_EmulationFaults

				case ffj_t_PerfStatistics_L1DcacheLoads:
					goto handle_L1DcacheLoads

				case ffj_t_PerfStatistics_L1DcacheLoadMisses:
					goto handle_L1DcacheLoadMisses

				case ffj_t_PerfStatistics_L1DcacheStores:
					goto handle_L1DcacheStores

				case ffj_t_PerfStatistics_L1DcacheStoreMisses:
					goto handle_L1DcacheStoreMisses

				case ffj_t_PerfStatistics_L1DcachePrefetches:
					goto handle_L1DcachePrefetches

				case ffj_t_PerfStatistics_L1DcachePrefetchMisses:
					goto handle_L1DcachePrefetchMisses

				case ffj_t_PerfStatistics_L1IcacheLoads:
					goto handle_L1IcacheLoads

				case ffj_t_PerfStatistics_L1IcacheLoadMisses:
					goto handle_L1IcacheLoadMisses

				case ffj_t_PerfStatistics_L1IcachePrefetches:
					goto handle_L1IcachePrefetches

				case ffj_t_PerfStatistics_L1IcachePrefetchMisses:
					goto handle_L1IcachePrefetchMisses

				case ffj_t_PerfStatistics_LlcLoads:
					goto handle_LlcLoads

				case ffj_t_PerfStatistics_LlcLoadMisses:
					goto handle_LlcLoadMisses

				case ffj_t_PerfStatistics_LlcStores:
					goto handle_LlcStores

				case ffj_t_PerfStatistics_LlcStoreMisses:
					goto handle_LlcStoreMisses

				case ffj_t_PerfStatistics_LlcPrefetches:
					goto handle_LlcPrefetches

				case ffj_t_PerfStatistics_LlcPrefetchMisses:
					goto handle_LlcPrefetchMisses

				case ffj_t_PerfStatistics_DtlbLoads:
					goto handle_DtlbLoads

				case ffj_t_PerfStatistics_DtlbLoadMisses:
					goto handle_DtlbLoadMisses

				case ffj_t_PerfStatistics_DtlbStores:
					goto handle_DtlbStores

				case ffj_t_PerfStatistics_DtlbStoreMisses:
					goto handle_DtlbStoreMisses

				case ffj_t_PerfStatistics_DtlbPrefetches:
					goto handle_DtlbPrefetches

				case ffj_t_PerfStatistics_DtlbPrefetchMisses:
					goto handle_DtlbPrefetchMisses

				case ffj_t_PerfStatistics_ItlbLoads:
					goto handle_ItlbLoads

				case ffj_t_PerfStatistics_ItlbLoadMisses:
					goto handle_ItlbLoadMisses

				case ffj_t_PerfStatistics_BranchLoads:
					goto handle_BranchLoads

				case ffj_t_PerfStatistics_BranchLoadMisses:
					goto handle_BranchLoadMisses

				case ffj_t_PerfStatistics_NodeLoads:
					goto handle_NodeLoads

				case ffj_t_PerfStatistics_NodeLoadMisses:
					goto handle_NodeLoadMisses

				case ffj_t_PerfStatistics_NodeStores:
					goto handle_NodeStores

				case ffj_t_PerfStatistics_NodeStoreMisses:
					goto handle_NodeStoreMisses

				case ffj_t_PerfStatistics_NodePrefetches:
					goto handle_NodePrefetches

				case ffj_t_PerfStatistics_NodePrefetchMisses:
					goto handle_NodePrefetchMisses

				case ffj_t_PerfStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Timestamp:

	/* handler: uj.Timestamp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Timestamp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cycles:

	/* handler: uj.Cycles type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Cycles = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Cycles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StalledCyclesFrontend:

	/* handler: uj.StalledCyclesFrontend type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.StalledCyclesFrontend = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.StalledCyclesFrontend = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StalledCyclesBackend:

	/* handler: uj.StalledCyclesBackend type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.StalledCyclesBackend = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.StalledCyclesBackend = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Instructions:

	/* handler: uj.Instructions type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Instructions = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Instructions = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CacheReferences:

	/* handler: uj.CacheReferences type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CacheReferences = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.CacheReferences = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CacheMisses:

	/* handler: uj.CacheMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CacheMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.CacheMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Branches:

	/* handler: uj.Branches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Branches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Branches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BranchMisses:

	/* handler: uj.BranchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BranchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BranchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BusCycles:

	/* handler: uj.BusCycles type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BusCycles = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BusCycles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RefCycles:

	/* handler: uj.RefCycles type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RefCycles = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.RefCycles = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpuClock:

	/* handler: uj.CpuClock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpuClock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpuClock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaskClock:

	/* handler: uj.TaskClock type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.TaskClock = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.TaskClock = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageFaults:

	/* handler: uj.PageFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.PageFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.PageFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MinorFaults:

	/* handler: uj.MinorFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MinorFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MinorFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MajorFaults:

	/* handler: uj.MajorFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MajorFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MajorFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContextSwitches:

	/* handler: uj.ContextSwitches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ContextSwitches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.ContextSwitches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpuMigrations:

	/* handler: uj.CpuMigrations type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpuMigrations = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.CpuMigrations = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AlignmentFaults:

	/* handler: uj.AlignmentFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AlignmentFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.AlignmentFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmulationFaults:

	/* handler: uj.EmulationFaults type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.EmulationFaults = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.EmulationFaults = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheLoads:

	/* handler: uj.L1DcacheLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheLoadMisses:

	/* handler: uj.L1DcacheLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheStores:

	/* handler: uj.L1DcacheStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcacheStoreMisses:

	/* handler: uj.L1DcacheStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcacheStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcacheStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcachePrefetches:

	/* handler: uj.L1DcachePrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcachePrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcachePrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1DcachePrefetchMisses:

	/* handler: uj.L1DcachePrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1DcachePrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1DcachePrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcacheLoads:

	/* handler: uj.L1IcacheLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcacheLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcacheLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcacheLoadMisses:

	/* handler: uj.L1IcacheLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcacheLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcacheLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcachePrefetches:

	/* handler: uj.L1IcachePrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcachePrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcachePrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_L1IcachePrefetchMisses:

	/* handler: uj.L1IcachePrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.L1IcachePrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.L1IcachePrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcLoads:

	/* handler: uj.LlcLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcLoadMisses:

	/* handler: uj.LlcLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcStores:

	/* handler: uj.LlcStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcStoreMisses:

	/* handler: uj.LlcStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcPrefetches:

	/* handler: uj.LlcPrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcPrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcPrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LlcPrefetchMisses:

	/* handler: uj.LlcPrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.LlcPrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.LlcPrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbLoads:

	/* handler: uj.DtlbLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbLoadMisses:

	/* handler: uj.DtlbLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbStores:

	/* handler: uj.DtlbStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbStoreMisses:

	/* handler: uj.DtlbStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbPrefetches:

	/* handler: uj.DtlbPrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbPrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbPrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DtlbPrefetchMisses:

	/* handler: uj.DtlbPrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DtlbPrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DtlbPrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItlbLoads:

	/* handler: uj.ItlbLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ItlbLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.ItlbLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ItlbLoadMisses:

	/* handler: uj.ItlbLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ItlbLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.ItlbLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BranchLoads:

	/* handler: uj.BranchLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BranchLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BranchLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BranchLoadMisses:

	/* handler: uj.BranchLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.BranchLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.BranchLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeLoads:

	/* handler: uj.NodeLoads type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeLoads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeLoads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeLoadMisses:

	/* handler: uj.NodeLoadMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeLoadMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeLoadMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeStores:

	/* handler: uj.NodeStores type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeStores = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeStores = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeStoreMisses:

	/* handler: uj.NodeStoreMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodeStoreMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodeStoreMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodePrefetches:

	/* handler: uj.NodePrefetches type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodePrefetches = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodePrefetches = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodePrefetchMisses:

	/* handler: uj.NodePrefetchMisses type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NodePrefetchMisses = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NodePrefetchMisses = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Port) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Port) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "number":`)
	fflib.FormatBits2(buf, uint64(mj.Number), 10, false)
	buf.WriteByte(',')
	if mj.Name != nil {
		if true {
			buf.WriteString(`"name":`)
			fflib.WriteJsonString(buf, string(*mj.Name))
			buf.WriteByte(',')
		}
	}
	if mj.Protocol != nil {
		if true {
			buf.WriteString(`"protocol":`)
			fflib.WriteJsonString(buf, string(*mj.Protocol))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Portbase = iota
	ffj_t_Portno_such_key

	ffj_t_Port_Number

	ffj_t_Port_Name

	ffj_t_Port_Protocol
)

var ffj_key_Port_Number = []byte("number")

var ffj_key_Port_Name = []byte("name")

var ffj_key_Port_Protocol = []byte("protocol")

func (uj *Port) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Port) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Portbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Portno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_Port_Number, kn) {
						currentKey = ffj_t_Port_Number
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Port_Name, kn) {
						currentKey = ffj_t_Port_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Port_Protocol, kn) {
						currentKey = ffj_t_Port_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Port_Protocol, kn) {
					currentKey = ffj_t_Port_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Port_Name, kn) {
					currentKey = ffj_t_Port_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Port_Number, kn) {
					currentKey = ffj_t_Port_Number
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Portno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Port_Number:
					goto handle_Number

				case ffj_t_Port_Name:
					goto handle_Name

				case ffj_t_Port_Protocol:
					goto handle_Protocol

				case ffj_t_Portno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Number:

	/* handler: uj.Number type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Number = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Name = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Name = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Protocol = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Protocol = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Ports) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Ports) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Ports) != 0 {
		buf.WriteString(`"ports":`)
		if mj.Ports != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Ports {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Portsbase = iota
	ffj_t_Portsno_such_key

	ffj_t_Ports_Ports
)

var ffj_key_Ports_Ports = []byte("ports")

func (uj *Ports) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Ports) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Portsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Portsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Ports_Ports, kn) {
						currentKey = ffj_t_Ports_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Ports_Ports, kn) {
					currentKey = ffj_t_Ports_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Portsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Ports_Ports:
					goto handle_Ports

				case ffj_t_Portsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ports:

	/* handler: uj.Ports type=[]*mesos.Port kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ports = nil
		} else {

			uj.Ports = make([]*Port, 0)

			wantVal := true

			for {

				var v *Port

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Port kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Port)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Ports = append(uj.Ports, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RateLimit) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RateLimit) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Qps != nil {
		if true {
			buf.WriteString(`"qps":`)
			fflib.AppendFloat(buf, float64(*mj.Qps), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"principal":`)
	fflib.WriteJsonString(buf, string(mj.Principal))
	buf.WriteByte(',')
	if mj.Capacity != nil {
		if true {
			buf.WriteString(`"capacity":`)
			fflib.FormatBits2(buf, uint64(*mj.Capacity), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RateLimitbase = iota
	ffj_t_RateLimitno_such_key

	ffj_t_RateLimit_Qps

	ffj_t_RateLimit_Principal

	ffj_t_RateLimit_Capacity
)

var ffj_key_RateLimit_Qps = []byte("qps")

var ffj_key_RateLimit_Principal = []byte("principal")

var ffj_key_RateLimit_Capacity = []byte("capacity")

func (uj *RateLimit) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RateLimit) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RateLimitbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RateLimitno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_RateLimit_Capacity, kn) {
						currentKey = ffj_t_RateLimit_Capacity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_RateLimit_Principal, kn) {
						currentKey = ffj_t_RateLimit_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_RateLimit_Qps, kn) {
						currentKey = ffj_t_RateLimit_Qps
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_RateLimit_Capacity, kn) {
					currentKey = ffj_t_RateLimit_Capacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RateLimit_Principal, kn) {
					currentKey = ffj_t_RateLimit_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RateLimit_Qps, kn) {
					currentKey = ffj_t_RateLimit_Qps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RateLimitno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RateLimit_Qps:
					goto handle_Qps

				case ffj_t_RateLimit_Principal:
					goto handle_Principal

				case ffj_t_RateLimit_Capacity:
					goto handle_Capacity

				case ffj_t_RateLimitno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Qps:

	/* handler: uj.Qps type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Qps = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Qps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Principal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Capacity:

	/* handler: uj.Capacity type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Capacity = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Capacity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RateLimits) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RateLimits) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Limits) != 0 {
		buf.WriteString(`"limits":`)
		if mj.Limits != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Limits {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.AggregateDefaultQps != nil {
		if true {
			buf.WriteString(`"aggregate_default_qps":`)
			fflib.AppendFloat(buf, float64(*mj.AggregateDefaultQps), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.AggregateDefaultCapacity != nil {
		if true {
			buf.WriteString(`"aggregate_default_capacity":`)
			fflib.FormatBits2(buf, uint64(*mj.AggregateDefaultCapacity), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RateLimitsbase = iota
	ffj_t_RateLimitsno_such_key

	ffj_t_RateLimits_Limits

	ffj_t_RateLimits_AggregateDefaultQps

	ffj_t_RateLimits_AggregateDefaultCapacity
)

var ffj_key_RateLimits_Limits = []byte("limits")

var ffj_key_RateLimits_AggregateDefaultQps = []byte("aggregate_default_qps")

var ffj_key_RateLimits_AggregateDefaultCapacity = []byte("aggregate_default_capacity")

func (uj *RateLimits) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RateLimits) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RateLimitsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RateLimitsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_RateLimits_AggregateDefaultQps, kn) {
						currentKey = ffj_t_RateLimits_AggregateDefaultQps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_RateLimits_AggregateDefaultCapacity, kn) {
						currentKey = ffj_t_RateLimits_AggregateDefaultCapacity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_RateLimits_Limits, kn) {
						currentKey = ffj_t_RateLimits_Limits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_RateLimits_AggregateDefaultCapacity, kn) {
					currentKey = ffj_t_RateLimits_AggregateDefaultCapacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RateLimits_AggregateDefaultQps, kn) {
					currentKey = ffj_t_RateLimits_AggregateDefaultQps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RateLimits_Limits, kn) {
					currentKey = ffj_t_RateLimits_Limits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RateLimitsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RateLimits_Limits:
					goto handle_Limits

				case ffj_t_RateLimits_AggregateDefaultQps:
					goto handle_AggregateDefaultQps

				case ffj_t_RateLimits_AggregateDefaultCapacity:
					goto handle_AggregateDefaultCapacity

				case ffj_t_RateLimitsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Limits:

	/* handler: uj.Limits type=[]*mesos.RateLimit kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Limits = nil
		} else {

			uj.Limits = make([]*RateLimit, 0)

			wantVal := true

			for {

				var v *RateLimit

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.RateLimit kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(RateLimit)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Limits = append(uj.Limits, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AggregateDefaultQps:

	/* handler: uj.AggregateDefaultQps type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AggregateDefaultQps = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.AggregateDefaultQps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AggregateDefaultCapacity:

	/* handler: uj.AggregateDefaultCapacity type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.AggregateDefaultCapacity = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.AggregateDefaultCapacity = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Request) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Request) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.AgentId != nil {
		if true {
			buf.WriteString(`"agent_id":`)

			{

				err = mj.AgentId.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Requestbase = iota
	ffj_t_Requestno_such_key

	ffj_t_Request_AgentId

	ffj_t_Request_Resources
)

var ffj_key_Request_AgentId = []byte("agent_id")

var ffj_key_Request_Resources = []byte("resources")

func (uj *Request) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Request) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Requestbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Requestno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Request_AgentId, kn) {
						currentKey = ffj_t_Request_AgentId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Request_Resources, kn) {
						currentKey = ffj_t_Request_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Request_Resources, kn) {
					currentKey = ffj_t_Request_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Request_AgentId, kn) {
					currentKey = ffj_t_Request_AgentId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Requestno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Request_AgentId:
					goto handle_AgentId

				case ffj_t_Request_Resources:
					goto handle_Resources

				case ffj_t_Requestno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AgentId:

	/* handler: uj.AgentId type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentId = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentId == nil {
			uj.AgentId = new(AgentID)
		}

		err = uj.AgentId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Scalar != nil {
		if true {
			buf.WriteString(`"scalar":`)

			{

				err = mj.Scalar.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Ranges != nil {
		if true {
			buf.WriteString(`"ranges":`)

			{

				err = mj.Ranges.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Set != nil {
		if true {
			buf.WriteString(`"set":`)

			{

				err = mj.Set.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Role != nil {
		if true {
			buf.WriteString(`"role":`)
			fflib.WriteJsonString(buf, string(*mj.Role))
			buf.WriteByte(',')
		}
	}
	if mj.Reservation != nil {
		if true {
			buf.WriteString(`"reservation":`)

			{

				err = mj.Reservation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Disk != nil {
		if true {
			buf.WriteString(`"disk":`)

			{

				err = mj.Disk.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Revocable != nil {
		if true {
			buf.WriteString(`"revocable":`)

			{

				err = mj.Revocable.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resourcebase = iota
	ffj_t_Resourceno_such_key

	ffj_t_Resource_Name

	ffj_t_Resource_Type

	ffj_t_Resource_Scalar

	ffj_t_Resource_Ranges

	ffj_t_Resource_Set

	ffj_t_Resource_Role

	ffj_t_Resource_Reservation

	ffj_t_Resource_Disk

	ffj_t_Resource_Revocable
)

var ffj_key_Resource_Name = []byte("name")

var ffj_key_Resource_Type = []byte("type")

var ffj_key_Resource_Scalar = []byte("scalar")

var ffj_key_Resource_Ranges = []byte("ranges")

var ffj_key_Resource_Set = []byte("set")

var ffj_key_Resource_Role = []byte("role")

var ffj_key_Resource_Reservation = []byte("reservation")

var ffj_key_Resource_Disk = []byte("disk")

var ffj_key_Resource_Revocable = []byte("revocable")

func (uj *Resource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Resource_Disk, kn) {
						currentKey = ffj_t_Resource_Disk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Resource_Name, kn) {
						currentKey = ffj_t_Resource_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Resource_Ranges, kn) {
						currentKey = ffj_t_Resource_Ranges
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Role, kn) {
						currentKey = ffj_t_Resource_Role
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Reservation, kn) {
						currentKey = ffj_t_Resource_Reservation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Revocable, kn) {
						currentKey = ffj_t_Resource_Revocable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Resource_Scalar, kn) {
						currentKey = ffj_t_Resource_Scalar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Resource_Set, kn) {
						currentKey = ffj_t_Resource_Set
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Resource_Type, kn) {
						currentKey = ffj_t_Resource_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Revocable, kn) {
					currentKey = ffj_t_Resource_Revocable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Disk, kn) {
					currentKey = ffj_t_Resource_Disk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Reservation, kn) {
					currentKey = ffj_t_Resource_Reservation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Role, kn) {
					currentKey = ffj_t_Resource_Role
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Set, kn) {
					currentKey = ffj_t_Resource_Set
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Ranges, kn) {
					currentKey = ffj_t_Resource_Ranges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_Scalar, kn) {
					currentKey = ffj_t_Resource_Scalar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Type, kn) {
					currentKey = ffj_t_Resource_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_Name, kn) {
					currentKey = ffj_t_Resource_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_Name:
					goto handle_Name

				case ffj_t_Resource_Type:
					goto handle_Type

				case ffj_t_Resource_Scalar:
					goto handle_Scalar

				case ffj_t_Resource_Ranges:
					goto handle_Ranges

				case ffj_t_Resource_Set:
					goto handle_Set

				case ffj_t_Resource_Role:
					goto handle_Role

				case ffj_t_Resource_Reservation:
					goto handle_Reservation

				case ffj_t_Resource_Disk:
					goto handle_Disk

				case ffj_t_Resource_Revocable:
					goto handle_Revocable

				case ffj_t_Resourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=mesos.Value_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Value_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scalar:

	/* handler: uj.Scalar type=mesos.Value_Scalar kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Scalar = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Scalar == nil {
			uj.Scalar = new(Value_Scalar)
		}

		err = uj.Scalar.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ranges:

	/* handler: uj.Ranges type=mesos.Value_Ranges kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ranges = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ranges == nil {
			uj.Ranges = new(Value_Ranges)
		}

		err = uj.Ranges.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Set:

	/* handler: uj.Set type=mesos.Value_Set kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Set = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Set == nil {
			uj.Set = new(Value_Set)
		}

		err = uj.Set.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: uj.Role type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Role = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Role = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reservation:

	/* handler: uj.Reservation type=mesos.Resource_ReservationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reservation = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Reservation == nil {
			uj.Reservation = new(Resource_ReservationInfo)
		}

		err = uj.Reservation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Disk:

	/* handler: uj.Disk type=mesos.Resource_DiskInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Disk = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Disk == nil {
			uj.Disk = new(Resource_DiskInfo)
		}

		err = uj.Disk.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Revocable:

	/* handler: uj.Revocable type=mesos.Resource_RevocableInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Revocable = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Revocable == nil {
			uj.Revocable = new(Resource_RevocableInfo)
		}

		err = uj.Revocable.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "timestamp":`)
	fflib.AppendFloat(buf, float64(mj.Timestamp), 'g', -1, 64)
	buf.WriteByte(',')
	if mj.Processes != nil {
		if true {
			buf.WriteString(`"processes":`)
			fflib.FormatBits2(buf, uint64(*mj.Processes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Threads != nil {
		if true {
			buf.WriteString(`"threads":`)
			fflib.FormatBits2(buf, uint64(*mj.Threads), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpusUserTimeSecs != nil {
		if true {
			buf.WriteString(`"cpus_user_time_secs":`)
			fflib.AppendFloat(buf, float64(*mj.CpusUserTimeSecs), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.CpusSystemTimeSecs != nil {
		if true {
			buf.WriteString(`"cpus_system_time_secs":`)
			fflib.AppendFloat(buf, float64(*mj.CpusSystemTimeSecs), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.CpusLimit != nil {
		if true {
			buf.WriteString(`"cpus_limit":`)
			fflib.AppendFloat(buf, float64(*mj.CpusLimit), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.CpusNrPeriods != nil {
		if true {
			buf.WriteString(`"cpus_nr_periods":`)
			fflib.FormatBits2(buf, uint64(*mj.CpusNrPeriods), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpusNrThrottled != nil {
		if true {
			buf.WriteString(`"cpus_nr_throttled":`)
			fflib.FormatBits2(buf, uint64(*mj.CpusNrThrottled), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.CpusThrottledTimeSecs != nil {
		if true {
			buf.WriteString(`"cpus_throttled_time_secs":`)
			fflib.AppendFloat(buf, float64(*mj.CpusThrottledTimeSecs), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.MemTotalBytes != nil {
		if true {
			buf.WriteString(`"mem_total_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemTotalBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemTotalMemswBytes != nil {
		if true {
			buf.WriteString(`"mem_total_memsw_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemTotalMemswBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemLimitBytes != nil {
		if true {
			buf.WriteString(`"mem_limit_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemLimitBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemSoftLimitBytes != nil {
		if true {
			buf.WriteString(`"mem_soft_limit_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemSoftLimitBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemFileBytes != nil {
		if true {
			buf.WriteString(`"mem_file_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemFileBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemAnonBytes != nil {
		if true {
			buf.WriteString(`"mem_anon_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemAnonBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemCacheBytes != nil {
		if true {
			buf.WriteString(`"mem_cache_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemCacheBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemRssBytes != nil {
		if true {
			buf.WriteString(`"mem_rss_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemRssBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemMappedFileBytes != nil {
		if true {
			buf.WriteString(`"mem_mapped_file_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemMappedFileBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemSwapBytes != nil {
		if true {
			buf.WriteString(`"mem_swap_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.MemSwapBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemLowPressureCounter != nil {
		if true {
			buf.WriteString(`"mem_low_pressure_counter":`)
			fflib.FormatBits2(buf, uint64(*mj.MemLowPressureCounter), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemMediumPressureCounter != nil {
		if true {
			buf.WriteString(`"mem_medium_pressure_counter":`)
			fflib.FormatBits2(buf, uint64(*mj.MemMediumPressureCounter), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.MemCriticalPressureCounter != nil {
		if true {
			buf.WriteString(`"mem_critical_pressure_counter":`)
			fflib.FormatBits2(buf, uint64(*mj.MemCriticalPressureCounter), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DiskLimitBytes != nil {
		if true {
			buf.WriteString(`"disk_limit_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.DiskLimitBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.DiskUsedBytes != nil {
		if true {
			buf.WriteString(`"disk_used_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.DiskUsedBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Perf != nil {
		if true {
			buf.WriteString(`"perf":`)

			{

				err = mj.Perf.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.NetRxPackets != nil {
		if true {
			buf.WriteString(`"net_rx_packets":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxPackets), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetRxBytes != nil {
		if true {
			buf.WriteString(`"net_rx_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetRxErrors != nil {
		if true {
			buf.WriteString(`"net_rx_errors":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxErrors), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetRxDropped != nil {
		if true {
			buf.WriteString(`"net_rx_dropped":`)
			fflib.FormatBits2(buf, uint64(*mj.NetRxDropped), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxPackets != nil {
		if true {
			buf.WriteString(`"net_tx_packets":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxPackets), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxBytes != nil {
		if true {
			buf.WriteString(`"net_tx_bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxBytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxErrors != nil {
		if true {
			buf.WriteString(`"net_tx_errors":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxErrors), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTxDropped != nil {
		if true {
			buf.WriteString(`"net_tx_dropped":`)
			fflib.FormatBits2(buf, uint64(*mj.NetTxDropped), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP50 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p50":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP50), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP90 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p90":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP90), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP95 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p95":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP95), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpRttMicrosecsP99 != nil {
		if true {
			buf.WriteString(`"net_tcp_rtt_microsecs_p99":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpRttMicrosecsP99), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpActiveConnections != nil {
		if true {
			buf.WriteString(`"net_tcp_active_connections":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpActiveConnections), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if mj.NetTcpTimeWaitConnections != nil {
		if true {
			buf.WriteString(`"net_tcp_time_wait_connections":`)
			fflib.AppendFloat(buf, float64(*mj.NetTcpTimeWaitConnections), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if len(mj.NetTrafficControlStatistics) != 0 {
		buf.WriteString(`"net_traffic_control_statistics":`)
		if mj.NetTrafficControlStatistics != nil {
			buf.WriteString(`[`)
			for i, v := range mj.NetTrafficControlStatistics {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceStatisticsbase = iota
	ffj_t_ResourceStatisticsno_such_key

	ffj_t_ResourceStatistics_Timestamp

	ffj_t_ResourceStatistics_Processes

	ffj_t_ResourceStatistics_Threads

	ffj_t_ResourceStatistics_CpusUserTimeSecs

	ffj_t_ResourceStatistics_CpusSystemTimeSecs

	ffj_t_ResourceStatistics_CpusLimit

	ffj_t_ResourceStatistics_CpusNrPeriods

	ffj_t_ResourceStatistics_CpusNrThrottled

	ffj_t_ResourceStatistics_CpusThrottledTimeSecs

	ffj_t_ResourceStatistics_MemTotalBytes

	ffj_t_ResourceStatistics_MemTotalMemswBytes

	ffj_t_ResourceStatistics_MemLimitBytes

	ffj_t_ResourceStatistics_MemSoftLimitBytes

	ffj_t_ResourceStatistics_MemFileBytes

	ffj_t_ResourceStatistics_MemAnonBytes

	ffj_t_ResourceStatistics_MemCacheBytes

	ffj_t_ResourceStatistics_MemRssBytes

	ffj_t_ResourceStatistics_MemMappedFileBytes

	ffj_t_ResourceStatistics_MemSwapBytes

	ffj_t_ResourceStatistics_MemLowPressureCounter

	ffj_t_ResourceStatistics_MemMediumPressureCounter

	ffj_t_ResourceStatistics_MemCriticalPressureCounter

	ffj_t_ResourceStatistics_DiskLimitBytes

	ffj_t_ResourceStatistics_DiskUsedBytes

	ffj_t_ResourceStatistics_Perf

	ffj_t_ResourceStatistics_NetRxPackets

	ffj_t_ResourceStatistics_NetRxBytes

	ffj_t_ResourceStatistics_NetRxErrors

	ffj_t_ResourceStatistics_NetRxDropped

	ffj_t_ResourceStatistics_NetTxPackets

	ffj_t_ResourceStatistics_NetTxBytes

	ffj_t_ResourceStatistics_NetTxErrors

	ffj_t_ResourceStatistics_NetTxDropped

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95

	ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99

	ffj_t_ResourceStatistics_NetTcpActiveConnections

	ffj_t_ResourceStatistics_NetTcpTimeWaitConnections

	ffj_t_ResourceStatistics_NetTrafficControlStatistics
)

var ffj_key_ResourceStatistics_Timestamp = []byte("timestamp")

var ffj_key_ResourceStatistics_Processes = []byte("processes")

var ffj_key_ResourceStatistics_Threads = []byte("threads")

var ffj_key_ResourceStatistics_CpusUserTimeSecs = []byte("cpus_user_time_secs")

var ffj_key_ResourceStatistics_CpusSystemTimeSecs = []byte("cpus_system_time_secs")

var ffj_key_ResourceStatistics_CpusLimit = []byte("cpus_limit")

var ffj_key_ResourceStatistics_CpusNrPeriods = []byte("cpus_nr_periods")

var ffj_key_ResourceStatistics_CpusNrThrottled = []byte("cpus_nr_throttled")

var ffj_key_ResourceStatistics_CpusThrottledTimeSecs = []byte("cpus_throttled_time_secs")

var ffj_key_ResourceStatistics_MemTotalBytes = []byte("mem_total_bytes")

var ffj_key_ResourceStatistics_MemTotalMemswBytes = []byte("mem_total_memsw_bytes")

var ffj_key_ResourceStatistics_MemLimitBytes = []byte("mem_limit_bytes")

var ffj_key_ResourceStatistics_MemSoftLimitBytes = []byte("mem_soft_limit_bytes")

var ffj_key_ResourceStatistics_MemFileBytes = []byte("mem_file_bytes")

var ffj_key_ResourceStatistics_MemAnonBytes = []byte("mem_anon_bytes")

var ffj_key_ResourceStatistics_MemCacheBytes = []byte("mem_cache_bytes")

var ffj_key_ResourceStatistics_MemRssBytes = []byte("mem_rss_bytes")

var ffj_key_ResourceStatistics_MemMappedFileBytes = []byte("mem_mapped_file_bytes")

var ffj_key_ResourceStatistics_MemSwapBytes = []byte("mem_swap_bytes")

var ffj_key_ResourceStatistics_MemLowPressureCounter = []byte("mem_low_pressure_counter")

var ffj_key_ResourceStatistics_MemMediumPressureCounter = []byte("mem_medium_pressure_counter")

var ffj_key_ResourceStatistics_MemCriticalPressureCounter = []byte("mem_critical_pressure_counter")

var ffj_key_ResourceStatistics_DiskLimitBytes = []byte("disk_limit_bytes")

var ffj_key_ResourceStatistics_DiskUsedBytes = []byte("disk_used_bytes")

var ffj_key_ResourceStatistics_Perf = []byte("perf")

var ffj_key_ResourceStatistics_NetRxPackets = []byte("net_rx_packets")

var ffj_key_ResourceStatistics_NetRxBytes = []byte("net_rx_bytes")

var ffj_key_ResourceStatistics_NetRxErrors = []byte("net_rx_errors")

var ffj_key_ResourceStatistics_NetRxDropped = []byte("net_rx_dropped")

var ffj_key_ResourceStatistics_NetTxPackets = []byte("net_tx_packets")

var ffj_key_ResourceStatistics_NetTxBytes = []byte("net_tx_bytes")

var ffj_key_ResourceStatistics_NetTxErrors = []byte("net_tx_errors")

var ffj_key_ResourceStatistics_NetTxDropped = []byte("net_tx_dropped")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP50 = []byte("net_tcp_rtt_microsecs_p50")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP90 = []byte("net_tcp_rtt_microsecs_p90")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP95 = []byte("net_tcp_rtt_microsecs_p95")

var ffj_key_ResourceStatistics_NetTcpRttMicrosecsP99 = []byte("net_tcp_rtt_microsecs_p99")

var ffj_key_ResourceStatistics_NetTcpActiveConnections = []byte("net_tcp_active_connections")

var ffj_key_ResourceStatistics_NetTcpTimeWaitConnections = []byte("net_tcp_time_wait_connections")

var ffj_key_ResourceStatistics_NetTrafficControlStatistics = []byte("net_traffic_control_statistics")

func (uj *ResourceStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ResourceStatistics_CpusUserTimeSecs, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusUserTimeSecs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusSystemTimeSecs, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusSystemTimeSecs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusLimit, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusLimit
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusNrPeriods, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusNrPeriods
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusNrThrottled, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusNrThrottled
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_CpusThrottledTimeSecs, kn) {
						currentKey = ffj_t_ResourceStatistics_CpusThrottledTimeSecs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ResourceStatistics_DiskLimitBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_DiskLimitBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_DiskUsedBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_DiskUsedBytes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ResourceStatistics_MemTotalBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemTotalBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemTotalMemswBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemTotalMemswBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemLimitBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemLimitBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemSoftLimitBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemSoftLimitBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemFileBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemFileBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemAnonBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemAnonBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemCacheBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemCacheBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemRssBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemRssBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemMappedFileBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemMappedFileBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemSwapBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_MemSwapBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemLowPressureCounter, kn) {
						currentKey = ffj_t_ResourceStatistics_MemLowPressureCounter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemMediumPressureCounter, kn) {
						currentKey = ffj_t_ResourceStatistics_MemMediumPressureCounter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_MemCriticalPressureCounter, kn) {
						currentKey = ffj_t_ResourceStatistics_MemCriticalPressureCounter
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ResourceStatistics_NetRxPackets, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxPackets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetRxBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetRxErrors, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetRxDropped, kn) {
						currentKey = ffj_t_ResourceStatistics_NetRxDropped
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxPackets, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxPackets
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxBytes, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxErrors, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTxDropped, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTxDropped
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP50, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP90, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP95, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP99, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpActiveConnections, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpActiveConnections
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTcpTimeWaitConnections, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTcpTimeWaitConnections
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_NetTrafficControlStatistics, kn) {
						currentKey = ffj_t_ResourceStatistics_NetTrafficControlStatistics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ResourceStatistics_Processes, kn) {
						currentKey = ffj_t_ResourceStatistics_Processes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_Perf, kn) {
						currentKey = ffj_t_ResourceStatistics_Perf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ResourceStatistics_Timestamp, kn) {
						currentKey = ffj_t_ResourceStatistics_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceStatistics_Threads, kn) {
						currentKey = ffj_t_ResourceStatistics_Threads
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTrafficControlStatistics, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTrafficControlStatistics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpTimeWaitConnections, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpTimeWaitConnections
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpActiveConnections, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpActiveConnections
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP99, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP95, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP90, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTcpRttMicrosecsP50, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ResourceStatistics_NetTxDropped, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxDropped
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTxErrors, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTxBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetTxPackets, kn) {
					currentKey = ffj_t_ResourceStatistics_NetTxPackets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ResourceStatistics_NetRxDropped, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxDropped
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetRxErrors, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetRxBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_NetRxPackets, kn) {
					currentKey = ffj_t_ResourceStatistics_NetRxPackets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceStatistics_Perf, kn) {
					currentKey = ffj_t_ResourceStatistics_Perf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_DiskUsedBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_DiskUsedBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_DiskLimitBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_DiskLimitBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemCriticalPressureCounter, kn) {
					currentKey = ffj_t_ResourceStatistics_MemCriticalPressureCounter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemMediumPressureCounter, kn) {
					currentKey = ffj_t_ResourceStatistics_MemMediumPressureCounter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemLowPressureCounter, kn) {
					currentKey = ffj_t_ResourceStatistics_MemLowPressureCounter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemSwapBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemSwapBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemMappedFileBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemMappedFileBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemRssBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemRssBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemCacheBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemCacheBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemAnonBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemAnonBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemFileBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemFileBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemSoftLimitBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemSoftLimitBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemLimitBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemLimitBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemTotalMemswBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemTotalMemswBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_MemTotalBytes, kn) {
					currentKey = ffj_t_ResourceStatistics_MemTotalBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusThrottledTimeSecs, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusThrottledTimeSecs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusNrThrottled, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusNrThrottled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusNrPeriods, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusNrPeriods
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusLimit, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusLimit
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusSystemTimeSecs, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusSystemTimeSecs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_CpusUserTimeSecs, kn) {
					currentKey = ffj_t_ResourceStatistics_CpusUserTimeSecs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_Threads, kn) {
					currentKey = ffj_t_ResourceStatistics_Threads
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_Processes, kn) {
					currentKey = ffj_t_ResourceStatistics_Processes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceStatistics_Timestamp, kn) {
					currentKey = ffj_t_ResourceStatistics_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceStatistics_Timestamp:
					goto handle_Timestamp

				case ffj_t_ResourceStatistics_Processes:
					goto handle_Processes

				case ffj_t_ResourceStatistics_Threads:
					goto handle_Threads

				case ffj_t_ResourceStatistics_CpusUserTimeSecs:
					goto handle_CpusUserTimeSecs

				case ffj_t_ResourceStatistics_CpusSystemTimeSecs:
					goto handle_CpusSystemTimeSecs

				case ffj_t_ResourceStatistics_CpusLimit:
					goto handle_CpusLimit

				case ffj_t_ResourceStatistics_CpusNrPeriods:
					goto handle_CpusNrPeriods

				case ffj_t_ResourceStatistics_CpusNrThrottled:
					goto handle_CpusNrThrottled

				case ffj_t_ResourceStatistics_CpusThrottledTimeSecs:
					goto handle_CpusThrottledTimeSecs

				case ffj_t_ResourceStatistics_MemTotalBytes:
					goto handle_MemTotalBytes

				case ffj_t_ResourceStatistics_MemTotalMemswBytes:
					goto handle_MemTotalMemswBytes

				case ffj_t_ResourceStatistics_MemLimitBytes:
					goto handle_MemLimitBytes

				case ffj_t_ResourceStatistics_MemSoftLimitBytes:
					goto handle_MemSoftLimitBytes

				case ffj_t_ResourceStatistics_MemFileBytes:
					goto handle_MemFileBytes

				case ffj_t_ResourceStatistics_MemAnonBytes:
					goto handle_MemAnonBytes

				case ffj_t_ResourceStatistics_MemCacheBytes:
					goto handle_MemCacheBytes

				case ffj_t_ResourceStatistics_MemRssBytes:
					goto handle_MemRssBytes

				case ffj_t_ResourceStatistics_MemMappedFileBytes:
					goto handle_MemMappedFileBytes

				case ffj_t_ResourceStatistics_MemSwapBytes:
					goto handle_MemSwapBytes

				case ffj_t_ResourceStatistics_MemLowPressureCounter:
					goto handle_MemLowPressureCounter

				case ffj_t_ResourceStatistics_MemMediumPressureCounter:
					goto handle_MemMediumPressureCounter

				case ffj_t_ResourceStatistics_MemCriticalPressureCounter:
					goto handle_MemCriticalPressureCounter

				case ffj_t_ResourceStatistics_DiskLimitBytes:
					goto handle_DiskLimitBytes

				case ffj_t_ResourceStatistics_DiskUsedBytes:
					goto handle_DiskUsedBytes

				case ffj_t_ResourceStatistics_Perf:
					goto handle_Perf

				case ffj_t_ResourceStatistics_NetRxPackets:
					goto handle_NetRxPackets

				case ffj_t_ResourceStatistics_NetRxBytes:
					goto handle_NetRxBytes

				case ffj_t_ResourceStatistics_NetRxErrors:
					goto handle_NetRxErrors

				case ffj_t_ResourceStatistics_NetRxDropped:
					goto handle_NetRxDropped

				case ffj_t_ResourceStatistics_NetTxPackets:
					goto handle_NetTxPackets

				case ffj_t_ResourceStatistics_NetTxBytes:
					goto handle_NetTxBytes

				case ffj_t_ResourceStatistics_NetTxErrors:
					goto handle_NetTxErrors

				case ffj_t_ResourceStatistics_NetTxDropped:
					goto handle_NetTxDropped

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP50:
					goto handle_NetTcpRttMicrosecsP50

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP90:
					goto handle_NetTcpRttMicrosecsP90

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP95:
					goto handle_NetTcpRttMicrosecsP95

				case ffj_t_ResourceStatistics_NetTcpRttMicrosecsP99:
					goto handle_NetTcpRttMicrosecsP99

				case ffj_t_ResourceStatistics_NetTcpActiveConnections:
					goto handle_NetTcpActiveConnections

				case ffj_t_ResourceStatistics_NetTcpTimeWaitConnections:
					goto handle_NetTcpTimeWaitConnections

				case ffj_t_ResourceStatistics_NetTrafficControlStatistics:
					goto handle_NetTrafficControlStatistics

				case ffj_t_ResourceStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Timestamp:

	/* handler: uj.Timestamp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Timestamp = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Processes:

	/* handler: uj.Processes type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Processes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Processes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Threads:

	/* handler: uj.Threads type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Threads = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Threads = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusUserTimeSecs:

	/* handler: uj.CpusUserTimeSecs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusUserTimeSecs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusUserTimeSecs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusSystemTimeSecs:

	/* handler: uj.CpusSystemTimeSecs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusSystemTimeSecs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusSystemTimeSecs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusLimit:

	/* handler: uj.CpusLimit type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusLimit = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusLimit = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusNrPeriods:

	/* handler: uj.CpusNrPeriods type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusNrPeriods = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.CpusNrPeriods = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusNrThrottled:

	/* handler: uj.CpusNrThrottled type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusNrThrottled = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.CpusNrThrottled = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CpusThrottledTimeSecs:

	/* handler: uj.CpusThrottledTimeSecs type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.CpusThrottledTimeSecs = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.CpusThrottledTimeSecs = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemTotalBytes:

	/* handler: uj.MemTotalBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemTotalBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemTotalBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemTotalMemswBytes:

	/* handler: uj.MemTotalMemswBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemTotalMemswBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemTotalMemswBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemLimitBytes:

	/* handler: uj.MemLimitBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemLimitBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemLimitBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemSoftLimitBytes:

	/* handler: uj.MemSoftLimitBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemSoftLimitBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemSoftLimitBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemFileBytes:

	/* handler: uj.MemFileBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemFileBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemFileBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemAnonBytes:

	/* handler: uj.MemAnonBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemAnonBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemAnonBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemCacheBytes:

	/* handler: uj.MemCacheBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemCacheBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemCacheBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemRssBytes:

	/* handler: uj.MemRssBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemRssBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemRssBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemMappedFileBytes:

	/* handler: uj.MemMappedFileBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemMappedFileBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemMappedFileBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemSwapBytes:

	/* handler: uj.MemSwapBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemSwapBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemSwapBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemLowPressureCounter:

	/* handler: uj.MemLowPressureCounter type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemLowPressureCounter = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemLowPressureCounter = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemMediumPressureCounter:

	/* handler: uj.MemMediumPressureCounter type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemMediumPressureCounter = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemMediumPressureCounter = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MemCriticalPressureCounter:

	/* handler: uj.MemCriticalPressureCounter type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.MemCriticalPressureCounter = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.MemCriticalPressureCounter = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiskLimitBytes:

	/* handler: uj.DiskLimitBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DiskLimitBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DiskLimitBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DiskUsedBytes:

	/* handler: uj.DiskUsedBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DiskUsedBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.DiskUsedBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Perf:

	/* handler: uj.Perf type=mesos.PerfStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Perf = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Perf == nil {
			uj.Perf = new(PerfStatistics)
		}

		err = uj.Perf.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxPackets:

	/* handler: uj.NetRxPackets type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxPackets = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxPackets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxBytes:

	/* handler: uj.NetRxBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxErrors:

	/* handler: uj.NetRxErrors type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxErrors = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetRxDropped:

	/* handler: uj.NetRxDropped type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetRxDropped = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetRxDropped = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxPackets:

	/* handler: uj.NetTxPackets type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxPackets = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxPackets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxBytes:

	/* handler: uj.NetTxBytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxBytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxBytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxErrors:

	/* handler: uj.NetTxErrors type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxErrors = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxErrors = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTxDropped:

	/* handler: uj.NetTxDropped type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTxDropped = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.NetTxDropped = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP50:

	/* handler: uj.NetTcpRttMicrosecsP50 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP50 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP50 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP90:

	/* handler: uj.NetTcpRttMicrosecsP90 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP90 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP90 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP95:

	/* handler: uj.NetTcpRttMicrosecsP95 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP95 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP95 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpRttMicrosecsP99:

	/* handler: uj.NetTcpRttMicrosecsP99 type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpRttMicrosecsP99 = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpRttMicrosecsP99 = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpActiveConnections:

	/* handler: uj.NetTcpActiveConnections type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpActiveConnections = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpActiveConnections = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTcpTimeWaitConnections:

	/* handler: uj.NetTcpTimeWaitConnections type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.NetTcpTimeWaitConnections = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.NetTcpTimeWaitConnections = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetTrafficControlStatistics:

	/* handler: uj.NetTrafficControlStatistics type=[]*mesos.TrafficControlStatistics kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NetTrafficControlStatistics = nil
		} else {

			uj.NetTrafficControlStatistics = make([]*TrafficControlStatistics, 0)

			wantVal := true

			for {

				var v *TrafficControlStatistics

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.TrafficControlStatistics kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(TrafficControlStatistics)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.NetTrafficControlStatistics = append(uj.NetTrafficControlStatistics, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceUsage) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceUsage) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Executors) != 0 {
		buf.WriteString(`"executors":`)
		if mj.Executors != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Executors {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Total) != 0 {
		buf.WriteString(`"total":`)
		if mj.Total != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Total {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceUsagebase = iota
	ffj_t_ResourceUsageno_such_key

	ffj_t_ResourceUsage_Executors

	ffj_t_ResourceUsage_Total
)

var ffj_key_ResourceUsage_Executors = []byte("executors")

var ffj_key_ResourceUsage_Total = []byte("total")

func (uj *ResourceUsage) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceUsage) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceUsagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceUsageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_ResourceUsage_Executors, kn) {
						currentKey = ffj_t_ResourceUsage_Executors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ResourceUsage_Total, kn) {
						currentKey = ffj_t_ResourceUsage_Total
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceUsage_Total, kn) {
					currentKey = ffj_t_ResourceUsage_Total
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceUsage_Executors, kn) {
					currentKey = ffj_t_ResourceUsage_Executors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceUsageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceUsage_Executors:
					goto handle_Executors

				case ffj_t_ResourceUsage_Total:
					goto handle_Total

				case ffj_t_ResourceUsageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Executors:

	/* handler: uj.Executors type=[]*mesos.ResourceUsage_Executor kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Executors = nil
		} else {

			uj.Executors = make([]*ResourceUsage_Executor, 0)

			wantVal := true

			for {

				var v *ResourceUsage_Executor

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.ResourceUsage_Executor kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(ResourceUsage_Executor)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Executors = append(uj.Executors, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Total:

	/* handler: uj.Total type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Total = nil
		} else {

			uj.Total = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Total = append(uj.Total, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceUsage_Executor) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceUsage_Executor) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "executor_info":`)

	{

		err = mj.ExecutorInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if len(mj.Allocated) != 0 {
		buf.WriteString(`"allocated":`)
		if mj.Allocated != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Allocated {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Statistics != nil {
		if true {
			buf.WriteString(`"statistics":`)

			{

				err = mj.Statistics.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceUsage_Executorbase = iota
	ffj_t_ResourceUsage_Executorno_such_key

	ffj_t_ResourceUsage_Executor_ExecutorInfo

	ffj_t_ResourceUsage_Executor_Allocated

	ffj_t_ResourceUsage_Executor_Statistics
)

var ffj_key_ResourceUsage_Executor_ExecutorInfo = []byte("executor_info")

var ffj_key_ResourceUsage_Executor_Allocated = []byte("allocated")

var ffj_key_ResourceUsage_Executor_Statistics = []byte("statistics")

func (uj *ResourceUsage_Executor) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceUsage_Executor) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceUsage_Executorbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceUsage_Executorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_Allocated, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_Allocated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_ExecutorInfo, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_ExecutorInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ResourceUsage_Executor_Statistics, kn) {
						currentKey = ffj_t_ResourceUsage_Executor_Statistics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceUsage_Executor_Statistics, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_Statistics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceUsage_Executor_Allocated, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_Allocated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ResourceUsage_Executor_ExecutorInfo, kn) {
					currentKey = ffj_t_ResourceUsage_Executor_ExecutorInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceUsage_Executorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceUsage_Executor_ExecutorInfo:
					goto handle_ExecutorInfo

				case ffj_t_ResourceUsage_Executor_Allocated:
					goto handle_Allocated

				case ffj_t_ResourceUsage_Executor_Statistics:
					goto handle_Statistics

				case ffj_t_ResourceUsage_Executorno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExecutorInfo:

	/* handler: uj.ExecutorInfo type=mesos.ExecutorInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ExecutorInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Allocated:

	/* handler: uj.Allocated type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Allocated = nil
		} else {

			uj.Allocated = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Allocated = append(uj.Allocated, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Statistics:

	/* handler: uj.Statistics type=mesos.ResourceStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Statistics = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Statistics == nil {
			uj.Statistics = new(ResourceStatistics)
		}

		err = uj.Statistics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Persistence != nil {
		if true {
			buf.WriteString(`"persistence":`)

			{

				err = mj.Persistence.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Volume != nil {
		if true {
			buf.WriteString(`"volume":`)

			{

				err = mj.Volume.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfobase = iota
	ffj_t_Resource_DiskInfono_such_key

	ffj_t_Resource_DiskInfo_Persistence

	ffj_t_Resource_DiskInfo_Volume
)

var ffj_key_Resource_DiskInfo_Persistence = []byte("persistence")

var ffj_key_Resource_DiskInfo_Volume = []byte("volume")

func (uj *Resource_DiskInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Persistence, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Persistence
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Volume, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Volume
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Volume, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Volume
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Resource_DiskInfo_Persistence, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Persistence
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Persistence:
					goto handle_Persistence

				case ffj_t_Resource_DiskInfo_Volume:
					goto handle_Volume

				case ffj_t_Resource_DiskInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Persistence:

	/* handler: uj.Persistence type=mesos.Resource_DiskInfo_Persistence kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Persistence = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Persistence == nil {
			uj.Persistence = new(Resource_DiskInfo_Persistence)
		}

		err = uj.Persistence.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Volume:

	/* handler: uj.Volume type=mesos.Volume kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Volume = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Volume == nil {
			uj.Volume = new(Volume)
		}

		err = uj.Volume.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_DiskInfo_Persistence) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_DiskInfo_Persistence) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(mj.Id))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_DiskInfo_Persistencebase = iota
	ffj_t_Resource_DiskInfo_Persistenceno_such_key

	ffj_t_Resource_DiskInfo_Persistence_Id
)

var ffj_key_Resource_DiskInfo_Persistence_Id = []byte("id")

func (uj *Resource_DiskInfo_Persistence) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_DiskInfo_Persistence) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_DiskInfo_Persistencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_DiskInfo_Persistenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Resource_DiskInfo_Persistence_Id, kn) {
						currentKey = ffj_t_Resource_DiskInfo_Persistence_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_DiskInfo_Persistence_Id, kn) {
					currentKey = ffj_t_Resource_DiskInfo_Persistence_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_DiskInfo_Persistenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_DiskInfo_Persistence_Id:
					goto handle_Id

				case ffj_t_Resource_DiskInfo_Persistenceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: uj.Id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_ReservationInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_ReservationInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"principal":`)
	fflib.WriteJsonString(buf, string(mj.Principal))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Resource_ReservationInfobase = iota
	ffj_t_Resource_ReservationInfono_such_key

	ffj_t_Resource_ReservationInfo_Principal
)

var ffj_key_Resource_ReservationInfo_Principal = []byte("principal")

func (uj *Resource_ReservationInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_ReservationInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_ReservationInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_ReservationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Resource_ReservationInfo_Principal, kn) {
						currentKey = ffj_t_Resource_ReservationInfo_Principal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Resource_ReservationInfo_Principal, kn) {
					currentKey = ffj_t_Resource_ReservationInfo_Principal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Resource_ReservationInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_ReservationInfo_Principal:
					goto handle_Principal

				case ffj_t_Resource_ReservationInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Principal:

	/* handler: uj.Principal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Principal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Resource_RevocableInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Resource_RevocableInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_Resource_RevocableInfobase = iota
	ffj_t_Resource_RevocableInfono_such_key
)

func (uj *Resource_RevocableInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Resource_RevocableInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Resource_RevocableInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Resource_RevocableInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_Resource_RevocableInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Resource_RevocableInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TaskID) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TaskID) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TaskIDbase = iota
	ffj_t_TaskIDno_such_key

	ffj_t_TaskID_Value
)

var ffj_key_TaskID_Value = []byte("value")

func (uj *TaskID) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TaskID) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TaskIDbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TaskIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_TaskID_Value, kn) {
						currentKey = ffj_t_TaskID_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskID_Value, kn) {
					currentKey = ffj_t_TaskID_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TaskIDno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TaskID_Value:
					goto handle_Value

				case ffj_t_TaskIDno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TaskInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TaskInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"task_id":`)

	{

		err = mj.TaskId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"agent_id":`)

	{

		err = mj.AgentId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if len(mj.Resources) != 0 {
		buf.WriteString(`"resources":`)
		if mj.Resources != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Resources {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Executor != nil {
		if true {
			buf.WriteString(`"executor":`)

			{

				err = mj.Executor.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.HealthCheck != nil {
		if true {
			buf.WriteString(`"health_check":`)

			{

				err = mj.HealthCheck.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Discovery != nil {
		if true {
			buf.WriteString(`"discovery":`)

			{

				err = mj.Discovery.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TaskInfobase = iota
	ffj_t_TaskInfono_such_key

	ffj_t_TaskInfo_Name

	ffj_t_TaskInfo_TaskId

	ffj_t_TaskInfo_AgentId

	ffj_t_TaskInfo_Resources

	ffj_t_TaskInfo_Executor

	ffj_t_TaskInfo_Command

	ffj_t_TaskInfo_Container

	ffj_t_TaskInfo_Data

	ffj_t_TaskInfo_HealthCheck

	ffj_t_TaskInfo_Labels

	ffj_t_TaskInfo_Discovery
)

var ffj_key_TaskInfo_Name = []byte("name")

var ffj_key_TaskInfo_TaskId = []byte("task_id")

var ffj_key_TaskInfo_AgentId = []byte("agent_id")

var ffj_key_TaskInfo_Resources = []byte("resources")

var ffj_key_TaskInfo_Executor = []byte("executor")

var ffj_key_TaskInfo_Command = []byte("command")

var ffj_key_TaskInfo_Container = []byte("container")

var ffj_key_TaskInfo_Data = []byte("data")

var ffj_key_TaskInfo_HealthCheck = []byte("health_check")

var ffj_key_TaskInfo_Labels = []byte("labels")

var ffj_key_TaskInfo_Discovery = []byte("discovery")

func (uj *TaskInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TaskInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TaskInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TaskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TaskInfo_AgentId, kn) {
						currentKey = ffj_t_TaskInfo_AgentId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_TaskInfo_Command, kn) {
						currentKey = ffj_t_TaskInfo_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskInfo_Container, kn) {
						currentKey = ffj_t_TaskInfo_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TaskInfo_Data, kn) {
						currentKey = ffj_t_TaskInfo_Data
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskInfo_Discovery, kn) {
						currentKey = ffj_t_TaskInfo_Discovery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_TaskInfo_Executor, kn) {
						currentKey = ffj_t_TaskInfo_Executor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_TaskInfo_HealthCheck, kn) {
						currentKey = ffj_t_TaskInfo_HealthCheck
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_TaskInfo_Labels, kn) {
						currentKey = ffj_t_TaskInfo_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_TaskInfo_Name, kn) {
						currentKey = ffj_t_TaskInfo_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TaskInfo_Resources, kn) {
						currentKey = ffj_t_TaskInfo_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_TaskInfo_TaskId, kn) {
						currentKey = ffj_t_TaskInfo_TaskId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_Discovery, kn) {
					currentKey = ffj_t_TaskInfo_Discovery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_Labels, kn) {
					currentKey = ffj_t_TaskInfo_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_HealthCheck, kn) {
					currentKey = ffj_t_TaskInfo_HealthCheck
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Data, kn) {
					currentKey = ffj_t_TaskInfo_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Container, kn) {
					currentKey = ffj_t_TaskInfo_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Command, kn) {
					currentKey = ffj_t_TaskInfo_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Executor, kn) {
					currentKey = ffj_t_TaskInfo_Executor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_Resources, kn) {
					currentKey = ffj_t_TaskInfo_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TaskInfo_AgentId, kn) {
					currentKey = ffj_t_TaskInfo_AgentId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskInfo_TaskId, kn) {
					currentKey = ffj_t_TaskInfo_TaskId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskInfo_Name, kn) {
					currentKey = ffj_t_TaskInfo_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TaskInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TaskInfo_Name:
					goto handle_Name

				case ffj_t_TaskInfo_TaskId:
					goto handle_TaskId

				case ffj_t_TaskInfo_AgentId:
					goto handle_AgentId

				case ffj_t_TaskInfo_Resources:
					goto handle_Resources

				case ffj_t_TaskInfo_Executor:
					goto handle_Executor

				case ffj_t_TaskInfo_Command:
					goto handle_Command

				case ffj_t_TaskInfo_Container:
					goto handle_Container

				case ffj_t_TaskInfo_Data:
					goto handle_Data

				case ffj_t_TaskInfo_HealthCheck:
					goto handle_HealthCheck

				case ffj_t_TaskInfo_Labels:
					goto handle_Labels

				case ffj_t_TaskInfo_Discovery:
					goto handle_Discovery

				case ffj_t_TaskInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaskId:

	/* handler: uj.TaskId type=mesos.TaskID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.TaskId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentId:

	/* handler: uj.AgentId type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.AgentId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]*mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = make([]*Resource, 0)

			wantVal := true

			for {

				var v *Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Resource kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Resource)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Executor:

	/* handler: uj.Executor type=mesos.ExecutorInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Executor = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Executor == nil {
			uj.Executor = new(ExecutorInfo)
		}

		err = uj.Executor.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HealthCheck:

	/* handler: uj.HealthCheck type=mesos.HealthCheck kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.HealthCheck = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HealthCheck == nil {
			uj.HealthCheck = new(HealthCheck)
		}

		err = uj.HealthCheck.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Discovery:

	/* handler: uj.Discovery type=mesos.DiscoveryInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Discovery = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Discovery == nil {
			uj.Discovery = new(DiscoveryInfo)
		}

		err = uj.Discovery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TaskStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TaskStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "task_id":`)

	{

		err = mj.TaskId.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.State != nil {
		if true {
			buf.WriteString(`"state":`)

			{

				obj, err = mj.State.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Message != nil {
		if true {
			buf.WriteString(`"message":`)
			fflib.WriteJsonString(buf, string(*mj.Message))
			buf.WriteByte(',')
		}
	}
	if mj.Source != nil {
		if true {
			buf.WriteString(`"source":`)

			{

				obj, err = mj.Source.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Reason != nil {
		if true {
			buf.WriteString(`"reason":`)

			{

				obj, err = mj.Reason.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.AgentId != nil {
		if true {
			buf.WriteString(`"agent_id":`)

			{

				err = mj.AgentId.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ExecutorId != nil {
		if true {
			buf.WriteString(`"executor_id":`)

			{

				err = mj.ExecutorId.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.AppendFloat(buf, float64(*mj.Timestamp), 'g', -1, 64)
			buf.WriteByte(',')
		}
	}
	if len(mj.Uuid) != 0 {
		buf.WriteString(`"uuid":`)
		if mj.Uuid != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Uuid)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Healthy != nil {
		if true {
			if *mj.Healthy {
				buf.WriteString(`"healthy":true`)
			} else {
				buf.WriteString(`"healthy":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Labels != nil {
		if true {
			buf.WriteString(`"labels":`)

			{

				err = mj.Labels.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TaskStatusbase = iota
	ffj_t_TaskStatusno_such_key

	ffj_t_TaskStatus_TaskId

	ffj_t_TaskStatus_State

	ffj_t_TaskStatus_Message

	ffj_t_TaskStatus_Source

	ffj_t_TaskStatus_Reason

	ffj_t_TaskStatus_Data

	ffj_t_TaskStatus_AgentId

	ffj_t_TaskStatus_ExecutorId

	ffj_t_TaskStatus_Timestamp

	ffj_t_TaskStatus_Uuid

	ffj_t_TaskStatus_Healthy

	ffj_t_TaskStatus_Labels
)

var ffj_key_TaskStatus_TaskId = []byte("task_id")

var ffj_key_TaskStatus_State = []byte("state")

var ffj_key_TaskStatus_Message = []byte("message")

var ffj_key_TaskStatus_Source = []byte("source")

var ffj_key_TaskStatus_Reason = []byte("reason")

var ffj_key_TaskStatus_Data = []byte("data")

var ffj_key_TaskStatus_AgentId = []byte("agent_id")

var ffj_key_TaskStatus_ExecutorId = []byte("executor_id")

var ffj_key_TaskStatus_Timestamp = []byte("timestamp")

var ffj_key_TaskStatus_Uuid = []byte("uuid")

var ffj_key_TaskStatus_Healthy = []byte("healthy")

var ffj_key_TaskStatus_Labels = []byte("labels")

func (uj *TaskStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TaskStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TaskStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TaskStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TaskStatus_AgentId, kn) {
						currentKey = ffj_t_TaskStatus_AgentId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TaskStatus_Data, kn) {
						currentKey = ffj_t_TaskStatus_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_TaskStatus_ExecutorId, kn) {
						currentKey = ffj_t_TaskStatus_ExecutorId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_TaskStatus_Healthy, kn) {
						currentKey = ffj_t_TaskStatus_Healthy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_TaskStatus_Labels, kn) {
						currentKey = ffj_t_TaskStatus_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_TaskStatus_Message, kn) {
						currentKey = ffj_t_TaskStatus_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TaskStatus_Reason, kn) {
						currentKey = ffj_t_TaskStatus_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_TaskStatus_State, kn) {
						currentKey = ffj_t_TaskStatus_State
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskStatus_Source, kn) {
						currentKey = ffj_t_TaskStatus_Source
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_TaskStatus_TaskId, kn) {
						currentKey = ffj_t_TaskStatus_TaskId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TaskStatus_Timestamp, kn) {
						currentKey = ffj_t_TaskStatus_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_TaskStatus_Uuid, kn) {
						currentKey = ffj_t_TaskStatus_Uuid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Labels, kn) {
					currentKey = ffj_t_TaskStatus_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskStatus_Healthy, kn) {
					currentKey = ffj_t_TaskStatus_Healthy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskStatus_Uuid, kn) {
					currentKey = ffj_t_TaskStatus_Uuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Timestamp, kn) {
					currentKey = ffj_t_TaskStatus_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TaskStatus_ExecutorId, kn) {
					currentKey = ffj_t_TaskStatus_ExecutorId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_TaskStatus_AgentId, kn) {
					currentKey = ffj_t_TaskStatus_AgentId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TaskStatus_Data, kn) {
					currentKey = ffj_t_TaskStatus_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Reason, kn) {
					currentKey = ffj_t_TaskStatus_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Source, kn) {
					currentKey = ffj_t_TaskStatus_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_Message, kn) {
					currentKey = ffj_t_TaskStatus_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_State, kn) {
					currentKey = ffj_t_TaskStatus_State
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TaskStatus_TaskId, kn) {
					currentKey = ffj_t_TaskStatus_TaskId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TaskStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TaskStatus_TaskId:
					goto handle_TaskId

				case ffj_t_TaskStatus_State:
					goto handle_State

				case ffj_t_TaskStatus_Message:
					goto handle_Message

				case ffj_t_TaskStatus_Source:
					goto handle_Source

				case ffj_t_TaskStatus_Reason:
					goto handle_Reason

				case ffj_t_TaskStatus_Data:
					goto handle_Data

				case ffj_t_TaskStatus_AgentId:
					goto handle_AgentId

				case ffj_t_TaskStatus_ExecutorId:
					goto handle_ExecutorId

				case ffj_t_TaskStatus_Timestamp:
					goto handle_Timestamp

				case ffj_t_TaskStatus_Uuid:
					goto handle_Uuid

				case ffj_t_TaskStatus_Healthy:
					goto handle_Healthy

				case ffj_t_TaskStatus_Labels:
					goto handle_Labels

				case ffj_t_TaskStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TaskId:

	/* handler: uj.TaskId type=mesos.TaskID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.TaskId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: uj.State type=mesos.TaskState kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.State = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.State == nil {
			uj.State = new(TaskState)
		}

		err = uj.State.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Message = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Message = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=mesos.TaskStatus_Source kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Source = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Source == nil {
			uj.Source = new(TaskStatus_Source)
		}

		err = uj.Source.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=mesos.TaskStatus_Reason kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reason = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Reason == nil {
			uj.Reason = new(TaskStatus_Reason)
		}

		err = uj.Reason.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AgentId:

	/* handler: uj.AgentId type=mesos.AgentID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentId = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentId == nil {
			uj.AgentId = new(AgentID)
		}

		err = uj.AgentId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutorId:

	/* handler: uj.ExecutorId type=mesos.ExecutorID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ExecutorId = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ExecutorId == nil {
			uj.ExecutorId = new(ExecutorID)
		}

		err = uj.ExecutorId.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := float64(tval)
			uj.Timestamp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uuid:

	/* handler: uj.Uuid type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Uuid = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Uuid).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Healthy:

	/* handler: uj.Healthy type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Healthy = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Healthy = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=mesos.Labels kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Labels = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Labels == nil {
			uj.Labels = new(Labels)
		}

		err = uj.Labels.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TimeInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TimeInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"nanoseconds":`)
	fflib.FormatBits2(buf, uint64(mj.Nanoseconds), 10, mj.Nanoseconds < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TimeInfobase = iota
	ffj_t_TimeInfono_such_key

	ffj_t_TimeInfo_Nanoseconds
)

var ffj_key_TimeInfo_Nanoseconds = []byte("nanoseconds")

func (uj *TimeInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TimeInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TimeInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TimeInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_TimeInfo_Nanoseconds, kn) {
						currentKey = ffj_t_TimeInfo_Nanoseconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TimeInfo_Nanoseconds, kn) {
					currentKey = ffj_t_TimeInfo_Nanoseconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TimeInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TimeInfo_Nanoseconds:
					goto handle_Nanoseconds

				case ffj_t_TimeInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Nanoseconds:

	/* handler: uj.Nanoseconds type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Nanoseconds = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TrafficControlStatistics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TrafficControlStatistics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(mj.Id))
	buf.WriteByte(',')
	if mj.Backlog != nil {
		if true {
			buf.WriteString(`"backlog":`)
			fflib.FormatBits2(buf, uint64(*mj.Backlog), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Bytes != nil {
		if true {
			buf.WriteString(`"bytes":`)
			fflib.FormatBits2(buf, uint64(*mj.Bytes), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Drops != nil {
		if true {
			buf.WriteString(`"drops":`)
			fflib.FormatBits2(buf, uint64(*mj.Drops), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Overlimits != nil {
		if true {
			buf.WriteString(`"overlimits":`)
			fflib.FormatBits2(buf, uint64(*mj.Overlimits), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Packets != nil {
		if true {
			buf.WriteString(`"packets":`)
			fflib.FormatBits2(buf, uint64(*mj.Packets), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Qlen != nil {
		if true {
			buf.WriteString(`"qlen":`)
			fflib.FormatBits2(buf, uint64(*mj.Qlen), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Ratebps != nil {
		if true {
			buf.WriteString(`"ratebps":`)
			fflib.FormatBits2(buf, uint64(*mj.Ratebps), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Ratepps != nil {
		if true {
			buf.WriteString(`"ratepps":`)
			fflib.FormatBits2(buf, uint64(*mj.Ratepps), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Requeues != nil {
		if true {
			buf.WriteString(`"requeues":`)
			fflib.FormatBits2(buf, uint64(*mj.Requeues), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TrafficControlStatisticsbase = iota
	ffj_t_TrafficControlStatisticsno_such_key

	ffj_t_TrafficControlStatistics_Id

	ffj_t_TrafficControlStatistics_Backlog

	ffj_t_TrafficControlStatistics_Bytes

	ffj_t_TrafficControlStatistics_Drops

	ffj_t_TrafficControlStatistics_Overlimits

	ffj_t_TrafficControlStatistics_Packets

	ffj_t_TrafficControlStatistics_Qlen

	ffj_t_TrafficControlStatistics_Ratebps

	ffj_t_TrafficControlStatistics_Ratepps

	ffj_t_TrafficControlStatistics_Requeues
)

var ffj_key_TrafficControlStatistics_Id = []byte("id")

var ffj_key_TrafficControlStatistics_Backlog = []byte("backlog")

var ffj_key_TrafficControlStatistics_Bytes = []byte("bytes")

var ffj_key_TrafficControlStatistics_Drops = []byte("drops")

var ffj_key_TrafficControlStatistics_Overlimits = []byte("overlimits")

var ffj_key_TrafficControlStatistics_Packets = []byte("packets")

var ffj_key_TrafficControlStatistics_Qlen = []byte("qlen")

var ffj_key_TrafficControlStatistics_Ratebps = []byte("ratebps")

var ffj_key_TrafficControlStatistics_Ratepps = []byte("ratepps")

var ffj_key_TrafficControlStatistics_Requeues = []byte("requeues")

func (uj *TrafficControlStatistics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TrafficControlStatistics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TrafficControlStatisticsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TrafficControlStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Backlog, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Backlog
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TrafficControlStatistics_Bytes, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Bytes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Drops, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Drops
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Id, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Id
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Overlimits, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Overlimits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Packets, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Packets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Qlen, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Qlen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_TrafficControlStatistics_Ratebps, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Ratebps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TrafficControlStatistics_Ratepps, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Ratepps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_TrafficControlStatistics_Requeues, kn) {
						currentKey = ffj_t_TrafficControlStatistics_Requeues
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Requeues, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Requeues
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Ratepps, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Ratepps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Ratebps, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Ratebps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TrafficControlStatistics_Qlen, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Qlen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Packets, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Packets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Overlimits, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Overlimits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Drops, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Drops
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Bytes, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Bytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TrafficControlStatistics_Backlog, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Backlog
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_TrafficControlStatistics_Id, kn) {
					currentKey = ffj_t_TrafficControlStatistics_Id
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TrafficControlStatisticsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TrafficControlStatistics_Id:
					goto handle_Id

				case ffj_t_TrafficControlStatistics_Backlog:
					goto handle_Backlog

				case ffj_t_TrafficControlStatistics_Bytes:
					goto handle_Bytes

				case ffj_t_TrafficControlStatistics_Drops:
					goto handle_Drops

				case ffj_t_TrafficControlStatistics_Overlimits:
					goto handle_Overlimits

				case ffj_t_TrafficControlStatistics_Packets:
					goto handle_Packets

				case ffj_t_TrafficControlStatistics_Qlen:
					goto handle_Qlen

				case ffj_t_TrafficControlStatistics_Ratebps:
					goto handle_Ratebps

				case ffj_t_TrafficControlStatistics_Ratepps:
					goto handle_Ratepps

				case ffj_t_TrafficControlStatistics_Requeues:
					goto handle_Requeues

				case ffj_t_TrafficControlStatisticsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: uj.Id type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Id = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Backlog:

	/* handler: uj.Backlog type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Backlog = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Backlog = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bytes:

	/* handler: uj.Bytes type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Bytes = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Bytes = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Drops:

	/* handler: uj.Drops type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Drops = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Drops = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Overlimits:

	/* handler: uj.Overlimits type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Overlimits = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Overlimits = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Packets:

	/* handler: uj.Packets type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Packets = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Packets = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Qlen:

	/* handler: uj.Qlen type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Qlen = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Qlen = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ratebps:

	/* handler: uj.Ratebps type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ratebps = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Ratebps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ratepps:

	/* handler: uj.Ratepps type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Ratepps = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Ratepps = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Requeues:

	/* handler: uj.Requeues type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Requeues = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Requeues = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *URL) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *URL) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "scheme":`)
	fflib.WriteJsonString(buf, string(mj.Scheme))
	buf.WriteString(`,"address":`)

	{

		err = mj.Address.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Path != nil {
		if true {
			buf.WriteString(`"path":`)
			fflib.WriteJsonString(buf, string(*mj.Path))
			buf.WriteByte(',')
		}
	}
	if len(mj.Query) != 0 {
		buf.WriteString(`"query":`)
		if mj.Query != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Query {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Fragment != nil {
		if true {
			buf.WriteString(`"fragment":`)
			fflib.WriteJsonString(buf, string(*mj.Fragment))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_URLbase = iota
	ffj_t_URLno_such_key

	ffj_t_URL_Scheme

	ffj_t_URL_Address

	ffj_t_URL_Path

	ffj_t_URL_Query

	ffj_t_URL_Fragment
)

var ffj_key_URL_Scheme = []byte("scheme")

var ffj_key_URL_Address = []byte("address")

var ffj_key_URL_Path = []byte("path")

var ffj_key_URL_Query = []byte("query")

var ffj_key_URL_Fragment = []byte("fragment")

func (uj *URL) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *URL) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_URLbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_URLno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_URL_Address, kn) {
						currentKey = ffj_t_URL_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_URL_Fragment, kn) {
						currentKey = ffj_t_URL_Fragment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_URL_Path, kn) {
						currentKey = ffj_t_URL_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_URL_Query, kn) {
						currentKey = ffj_t_URL_Query
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_URL_Scheme, kn) {
						currentKey = ffj_t_URL_Scheme
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_URL_Fragment, kn) {
					currentKey = ffj_t_URL_Fragment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_URL_Query, kn) {
					currentKey = ffj_t_URL_Query
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_URL_Path, kn) {
					currentKey = ffj_t_URL_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_URL_Address, kn) {
					currentKey = ffj_t_URL_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_URL_Scheme, kn) {
					currentKey = ffj_t_URL_Scheme
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_URLno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_URL_Scheme:
					goto handle_Scheme

				case ffj_t_URL_Address:
					goto handle_Address

				case ffj_t_URL_Path:
					goto handle_Path

				case ffj_t_URL_Query:
					goto handle_Query

				case ffj_t_URL_Fragment:
					goto handle_Fragment

				case ffj_t_URLno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Scheme:

	/* handler: uj.Scheme type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Scheme = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=mesos.Address kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Address.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Path = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Path = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: uj.Query type=[]*mesos.Parameter kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Query = nil
		} else {

			uj.Query = make([]*Parameter, 0)

			wantVal := true

			for {

				var v *Parameter

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=*mesos.Parameter kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						v = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if v == nil {
						v = new(Parameter)
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Query = append(uj.Query, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fragment:

	/* handler: uj.Fragment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Fragment = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Fragment = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Unavailability) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Unavailability) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "start":`)

	{

		err = mj.Start.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Duration != nil {
		if true {
			buf.WriteString(`"duration":`)

			{

				err = mj.Duration.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Unavailabilitybase = iota
	ffj_t_Unavailabilityno_such_key

	ffj_t_Unavailability_Start

	ffj_t_Unavailability_Duration
)

var ffj_key_Unavailability_Start = []byte("start")

var ffj_key_Unavailability_Duration = []byte("duration")

func (uj *Unavailability) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Unavailability) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Unavailabilitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Unavailabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Unavailability_Duration, kn) {
						currentKey = ffj_t_Unavailability_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Unavailability_Start, kn) {
						currentKey = ffj_t_Unavailability_Start
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Unavailability_Duration, kn) {
					currentKey = ffj_t_Unavailability_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Unavailability_Start, kn) {
					currentKey = ffj_t_Unavailability_Start
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Unavailabilityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Unavailability_Start:
					goto handle_Start

				case ffj_t_Unavailability_Duration:
					goto handle_Duration

				case ffj_t_Unavailabilityno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Start:

	/* handler: uj.Start type=mesos.TimeInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Start.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=mesos.DurationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Duration = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Duration == nil {
			uj.Duration = new(DurationInfo)
		}

		err = uj.Duration.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Type != nil {
		if true {
			buf.WriteString(`"type":`)

			{

				obj, err = mj.Type.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Scalar != nil {
		if true {
			buf.WriteString(`"scalar":`)

			{

				err = mj.Scalar.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Ranges != nil {
		if true {
			buf.WriteString(`"ranges":`)

			{

				err = mj.Ranges.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Set != nil {
		if true {
			buf.WriteString(`"set":`)

			{

				err = mj.Set.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Text != nil {
		if true {
			buf.WriteString(`"text":`)

			{

				err = mj.Text.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Valuebase = iota
	ffj_t_Valueno_such_key

	ffj_t_Value_Type

	ffj_t_Value_Scalar

	ffj_t_Value_Ranges

	ffj_t_Value_Set

	ffj_t_Value_Text
)

var ffj_key_Value_Type = []byte("type")

var ffj_key_Value_Scalar = []byte("scalar")

var ffj_key_Value_Ranges = []byte("ranges")

var ffj_key_Value_Set = []byte("set")

var ffj_key_Value_Text = []byte("text")

func (uj *Value) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Valuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Valueno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Value_Ranges, kn) {
						currentKey = ffj_t_Value_Ranges
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Value_Scalar, kn) {
						currentKey = ffj_t_Value_Scalar
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Value_Set, kn) {
						currentKey = ffj_t_Value_Set
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Value_Type, kn) {
						currentKey = ffj_t_Value_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Value_Text, kn) {
						currentKey = ffj_t_Value_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Text, kn) {
					currentKey = ffj_t_Value_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Value_Set, kn) {
					currentKey = ffj_t_Value_Set
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Value_Ranges, kn) {
					currentKey = ffj_t_Value_Ranges
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Value_Scalar, kn) {
					currentKey = ffj_t_Value_Scalar
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Type, kn) {
					currentKey = ffj_t_Value_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Valueno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Type:
					goto handle_Type

				case ffj_t_Value_Scalar:
					goto handle_Scalar

				case ffj_t_Value_Ranges:
					goto handle_Ranges

				case ffj_t_Value_Set:
					goto handle_Set

				case ffj_t_Value_Text:
					goto handle_Text

				case ffj_t_Valueno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=mesos.Value_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Type = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Type == nil {
			uj.Type = new(Value_Type)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scalar:

	/* handler: uj.Scalar type=mesos.Value_Scalar kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Scalar = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Scalar == nil {
			uj.Scalar = new(Value_Scalar)
		}

		err = uj.Scalar.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ranges:

	/* handler: uj.Ranges type=mesos.Value_Ranges kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Ranges = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Ranges == nil {
			uj.Ranges = new(Value_Ranges)
		}

		err = uj.Ranges.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Set:

	/* handler: uj.Set type=mesos.Value_Set kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Set = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Set == nil {
			uj.Set = new(Value_Set)
		}

		err = uj.Set.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=mesos.Value_Text kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Text = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Text == nil {
			uj.Text = new(Value_Text)
		}

		err = uj.Text.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Range) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Range) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"begin":`)
	fflib.FormatBits2(buf, uint64(mj.Begin), 10, false)
	buf.WriteString(`,"end":`)
	fflib.FormatBits2(buf, uint64(mj.End), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Rangebase = iota
	ffj_t_Value_Rangeno_such_key

	ffj_t_Value_Range_Begin

	ffj_t_Value_Range_End
)

var ffj_key_Value_Range_Begin = []byte("begin")

var ffj_key_Value_Range_End = []byte("end")

func (uj *Value_Range) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Range) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Rangebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Rangeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_Value_Range_Begin, kn) {
						currentKey = ffj_t_Value_Range_Begin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Value_Range_End, kn) {
						currentKey = ffj_t_Value_Range_End
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Range_End, kn) {
					currentKey = ffj_t_Value_Range_End
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Range_Begin, kn) {
					currentKey = ffj_t_Value_Range_Begin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Rangeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Range_Begin:
					goto handle_Begin

				case ffj_t_Value_Range_End:
					goto handle_End

				case ffj_t_Value_Rangeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Begin:

	/* handler: uj.Begin type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Begin = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_End:

	/* handler: uj.End type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.End = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Ranges) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Ranges) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"range":`)
	if mj.Range != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Range {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Rangesbase = iota
	ffj_t_Value_Rangesno_such_key

	ffj_t_Value_Ranges_Range
)

var ffj_key_Value_Ranges_Range = []byte("range")

func (uj *Value_Ranges) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Ranges) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Rangesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Rangesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Value_Ranges_Range, kn) {
						currentKey = ffj_t_Value_Ranges_Range
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Ranges_Range, kn) {
					currentKey = ffj_t_Value_Ranges_Range
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Rangesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Ranges_Range:
					goto handle_Range

				case ffj_t_Value_Rangesno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Range:

	/* handler: uj.Range type=[]mesos.Value_Range kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Range = nil
		} else {

			uj.Range = make([]Value_Range, 0)

			wantVal := true

			for {

				var v Value_Range

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mesos.Value_Range kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Range = append(uj.Range, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Scalar) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Scalar) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.AppendFloat(buf, float64(mj.Value), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Scalarbase = iota
	ffj_t_Value_Scalarno_such_key

	ffj_t_Value_Scalar_Value
)

var ffj_key_Value_Scalar_Value = []byte("value")

func (uj *Value_Scalar) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Scalar) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Scalarbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Scalarno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Value_Scalar_Value, kn) {
						currentKey = ffj_t_Value_Scalar_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Scalar_Value, kn) {
					currentKey = ffj_t_Value_Scalar_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Scalarno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Scalar_Value:
					goto handle_Value

				case ffj_t_Value_Scalarno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Value = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Set) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Set) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Item) != 0 {
		buf.WriteString(`"item":`)
		if mj.Item != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Item {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Setbase = iota
	ffj_t_Value_Setno_such_key

	ffj_t_Value_Set_Item
)

var ffj_key_Value_Set_Item = []byte("item")

func (uj *Value_Set) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Set) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Setbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Setno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Value_Set_Item, kn) {
						currentKey = ffj_t_Value_Set_Item
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Set_Item, kn) {
					currentKey = ffj_t_Value_Set_Item
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Setno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Set_Item:
					goto handle_Item

				case ffj_t_Value_Setno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Item:

	/* handler: uj.Item type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Item = nil
		} else {

			uj.Item = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Item = append(uj.Item, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Value_Text) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Value_Text) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Value_Textbase = iota
	ffj_t_Value_Textno_such_key

	ffj_t_Value_Text_Value
)

var ffj_key_Value_Text_Value = []byte("value")

func (uj *Value_Text) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Value_Text) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Value_Textbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Value_Textno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Value_Text_Value, kn) {
						currentKey = ffj_t_Value_Text_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Value_Text_Value, kn) {
					currentKey = ffj_t_Value_Text_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Value_Textno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Value_Text_Value:
					goto handle_Value

				case ffj_t_Value_Textno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Volume) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Volume) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Mode != nil {
		if true {
			buf.WriteString(`"mode":`)

			{

				obj, err = mj.Mode.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"container_path":`)
	fflib.WriteJsonString(buf, string(mj.ContainerPath))
	buf.WriteByte(',')
	if mj.HostPath != nil {
		if true {
			buf.WriteString(`"host_path":`)
			fflib.WriteJsonString(buf, string(*mj.HostPath))
			buf.WriteByte(',')
		}
	}
	if mj.Image != nil {
		if true {
			buf.WriteString(`"image":`)

			{

				err = mj.Image.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Volumebase = iota
	ffj_t_Volumeno_such_key

	ffj_t_Volume_Mode

	ffj_t_Volume_ContainerPath

	ffj_t_Volume_HostPath

	ffj_t_Volume_Image
)

var ffj_key_Volume_Mode = []byte("mode")

var ffj_key_Volume_ContainerPath = []byte("container_path")

var ffj_key_Volume_HostPath = []byte("host_path")

var ffj_key_Volume_Image = []byte("image")

func (uj *Volume) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Volume) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Volumebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Volumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Volume_ContainerPath, kn) {
						currentKey = ffj_t_Volume_ContainerPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Volume_HostPath, kn) {
						currentKey = ffj_t_Volume_HostPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Volume_Image, kn) {
						currentKey = ffj_t_Volume_Image
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Volume_Mode, kn) {
						currentKey = ffj_t_Volume_Mode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_Image, kn) {
					currentKey = ffj_t_Volume_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_HostPath, kn) {
					currentKey = ffj_t_Volume_HostPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Volume_ContainerPath, kn) {
					currentKey = ffj_t_Volume_ContainerPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_Mode, kn) {
					currentKey = ffj_t_Volume_Mode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Volumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Volume_Mode:
					goto handle_Mode

				case ffj_t_Volume_ContainerPath:
					goto handle_ContainerPath

				case ffj_t_Volume_HostPath:
					goto handle_HostPath

				case ffj_t_Volume_Image:
					goto handle_Image

				case ffj_t_Volumeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Mode:

	/* handler: uj.Mode type=mesos.Volume_Mode kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Mode = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Mode == nil {
			uj.Mode = new(Volume_Mode)
		}

		err = uj.Mode.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerPath:

	/* handler: uj.ContainerPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ContainerPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostPath:

	/* handler: uj.HostPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.HostPath = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.HostPath = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: uj.Image type=mesos.Image kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Image = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Image == nil {
			uj.Image = new(Image)
		}

		err = uj.Image.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
